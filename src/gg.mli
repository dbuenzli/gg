(*---------------------------------------------------------------------------
   Copyright (c) 2013 The gg programmers. All rights reserved.
   Distributed under the ISC license, see terms at the end of the file.
  ---------------------------------------------------------------------------*)

(** Basic types for computer graphics.

    [Gg] defines types and functions for {{!Float}floats},
    {{!vectors}vectors}, {{!points}points}, {{!matrices}matrices},
    {{!quaternions}quaternions}, {{!sizes}sizes},
    {{!aboxes}axis aligned boxes}, {{!colors}colors},
    {{!Color.colorprofiles}color profiles},
    {{!section-bigarray}linear bigarrays}
    and
    {{!section-raster}raster data}.

    Consult the {{!basics}basics}.

    Open the module to use it, this defines only modules and types in your
    scope. *)

(** {1:float Floats} *)

(** Floating point number utilities.

    This module extends the OCaml {!Stdlib.Float} module. It also
    provides {{!Float.floatrecall}this quick recall} on OCaml's
    floating point representation.

    {b Note.} Functions taking NaNs return NaNs unless otherwise
    specified.

    {b Warning.} This module existed before {!Stdlib.Float} was
    introduced in OCaml 4.07.0. Since [Gg] 1.0.0, the module now
    includes [Stdlib.Float] and some values initially provided by [Gg]
    are now provided by [Stdlib.Float], see the release notes of the
    package for a precise account of the changes. *)
module Float : sig

  (** {1:stdlib [Stdlib.Float]} *)

  include (module type of Stdlib.Float) (** @closed *)

  (** {1:constants Constants} *)

  val e : float
  (** The constant {{:http://mathworld.wolfram.com/e.html}e}. *)

  val two_pi : float
  (** [2 *. pi], two times {{:http://mathworld.wolfram.com/Pi.html}pi}. *)

  val pi_div_2 : float
  (** [pi /. 2]. *)

  val pi_div_4 : float
  (** [pi /. 4]. *)

  val inv_pi : float
  (** [1 /. pi]. *)

  val max_sub_float : float
  (** The greatest positive subnormal floating point number. *)

  val min_sub_float : float
  (** The smallest positive subnormal floating point number. *)

  val max_frac_float : float
  (** The greatest positive floating point number with a fractional
      part (the [float] before 2{^52}). Any number outside
      \[[-max_frac_float;max_frac_float]\] is an integer. *)

  val max_int_arith : float
  (** The greatest positive floating point number (2{^53}) such that
      any {e integer} in the range
      \[[-max_int_arith;max_int_arith]\] is represented exactly.
      Integer arithmetic can be performed exactly in this interval. *)

  (** {1:angles Angles} *)

  val deg_of_rad : float -> float
  (** [deg_of_rad r] is [r]
     {{:http://mathworld.wolfram.com/Radian.html}radians} in
     {{:http://mathworld.wolfram.com/Degree.html}degrees}. *)

  val rad_of_deg : float -> float
  (** [rad_of_deg d] is [d]
     {{:http://mathworld.wolfram.com/Degree.html}degrees} in
     {{:http://mathworld.wolfram.com/Radian.html}radians}. *)

  val wrap_angle : float -> float
  (** [wrap_angle r] is the angle [r] in the interval \[[-pi;pi]\[. *)

  (** {1:random Random} *)

  val random : ?min:float -> len:float -> unit -> float
  (** [random min len ()] is a random float in the interval
      \[[min;min+len]\] ([min] defaults to 0.). Uses the standard
      library's default [Random] state for the generation.

     {b Warning.} The float generated by a given state may
     change in future versions of the library. *)

  val srandom : Random.State.t -> ?min:float -> len:float -> unit -> float
  (** [srandom state min len ()] is like {!val-random} but uses [state]
      for the generation.

      {b Warning.} The float generated by a given [state] may
      change in future versions of the library. *)

  (** {1:intervals Intervals} *)

  val mix : float -> float -> float -> float
  (** [mix x y t] is the linear interpolation [x +. t *. (y -. x)]. *)

  val step : float -> float -> float
  (** [step edge x] is [0.] if [x < edge] and [1.] otherwise. The
      result is undefined on NaNs. *)

  val smooth_step : float -> float -> float -> float
  (** [smooth_step e0 e1 x] is [0.] if [x <= e0], [1.] if [x >= e1]
      and cubic hermite interpolation between 0. and 1. otherwise. The
      result is undefined on NaNs. *)

  val clamp : min:float -> max:float -> float -> float
  (** [clamp min max x] is [min] if [x < min], [max] if [x > max] and
      [x] otherwise. The result is undefined on NaNs and if [min >
      max]. *)

  val remap : x0:float -> x1:float -> y0:float -> y1:float -> float ->
    float
  (** [remap x0 x1 y0 y1 v] applies to [v] the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} that maps [x0] to [y0] and [x1] to [y1]. If the
      transform is undefined ([x0 = x1] and [y0 <> y1]) the function
      returns [y0] for any [v]. *)

  val seg_inter :
    u0:float -> u1:float -> v0:float -> v1:float ->
    [ `None | `Pt of float | `Seg of float * float ]
  (** [seg_inter ~u0 ~u1 ~v0 ~v1] is the intersection
      between segments (intervals) \[[u0];[u1]\] (with [u0] <= [u1])
      and \[[v0];[v1]\] (with [v0] <= [v1]). This
      is:

      - [`None] if the intervals are disjoint.
      - [`Pt x] if they intersect on the single point [x].
      - [`Seg (x0, x1)] if they intersect on the interval \[[x0];[x1]\]
        (with [x0 < x1]).

      {b Note.} Terminology uses segments rather intervals to match
      {!P2.seg_inter}. *)

  (** {1:round Rounding and truncating} *)

  val int_of_round : float -> int
  (** [int_of_round x] is [truncate (round v)]. The result is
      undefined on NaNs and infinities. *)

  val round_dfrac : int -> float -> float
  (** [round_dfrac d x] rounds [x] to the [d]th {e decimal} fractional
      digit. Ties are rounded towards positive infinity.  If [x] is an
      infinity, returns [x]. The result is only defined for [0 <= d <=
      16]. *)

  val round_dsig : int -> float -> float
  (** [round_dsig d x] rounds the normalized {e decimal} significand
      of [x] to the [d]th decimal fractional digit. Ties are rounded
      towards positive infinity. The result is NaN on infinities.  The
      result only defined for [0 <= d <= 16].

      {b Warning.} The current implementation overflows on large [x]
      and [d]. *)

  val round_zero : eps:float -> float -> float
  (** [round_zero eps x] is [0.] if [abs_float x < eps] and [x] otherwise.
      The result is undefined if [eps] is NaN. *)

  val chop : eps:float -> float -> float
  (**  [chop eps x] is [round x] if [abs_float (x -. round x) < eps] and [x]
       otherwise. The result is undefined if [eps] is NaN. *)

  (** {1:nan NaNs} *)

  val nan_with_payload : int -> float
  (** [nan_with_payload payload] is a NaN whose 51 lower significand bits are
      defined by the 51 lower (or less, as [int] allows) bits of
      [payload]. *)

  val nan_payload : float -> int
  (** [nan_payload x] is the 51 lower significand bits (or less, as
      [int] allows) of the NaN [x].

      Raises [Invalid_argument] if [x] is not a NaN. *)

  (** {1:preds Predicates and comparisons} *)

  val sign : float -> float
  (** [sign x] is [1.] if [x > 0.], [0.] if [x = 0.], [-1.] if [x < 0.] *)

  val is_zero : eps:float -> float -> bool
  (** [is_zero eps x] is [true] if [abs_float x < eps]
      and [false] otherwise. The result is undefined if [eps] is NaN. *)

  val equal_tol : eps:float -> float -> float -> bool
  (** [equal_tol eps x y] is [true] iff |[x - y]| <= [eps] * max
      (1,|[x]|,|[y]|). On special values the function behaves like
      [compare x y = 0].  The condition turns into an absolute tolerance
      test for small magnitudes and a relative tolerance test for
      large magnitudes. *)

  val compare_tol : eps:float -> float -> float -> int
  (** [compare_tol ~eps x y] is [0] iff [equal_tol ~eps x y] is [true]
      and [Stdlib.compare x y] otherwise. *)

  (** {1:fmt Formatting} *)

  val pp : Format.formatter -> float -> unit
  (** [pp ppf x] formats a lossless textual representation of [x] on
      [ppf] using ["%h"]. Since 1.0.0, before this was the slower
      {!legacy_pp} whose output differs on the representation of nan,
      infinities, or zeros. *)

  (** {1:deprecated Deprecated} *)

  val fmax : float -> float -> float
  [@@ocaml.deprecated "Use Float.max_num instead."]
  (** Deprecated use {!max_num}. *)

  val fmin : float -> float -> float
  [@@ocaml.deprecated "Use Float.min_num instead."]
  (** Deprecated use {!min_num}. *)

  val is_inf : float -> bool
  [@@ocaml.deprecated "Use Float.is_infinite instead."]
  (** Deprecated use {!is_infinite}. *)

  val is_int : float -> bool
  [@@ocaml.deprecated "Use Float.is_integer instead."]
  (** Deprecated use {!is_integer}. *)

  val legacy_pp : Format.formatter -> float -> unit
  [@@ocaml.deprecated
    "Use Float.pp instead (some values may render differently)."]
  (** Deprecated use {!pp}.

     [pp_legacy ppf x] prints a lossless textual representation of [x]
     on [ppf].

      {ul
      {- Normals are represented by ["[-]0x1.<f>p<e>"] where
         [<f>] is the significand bits in hexadecimal and [<e>] the
         unbiased exponent in decimal.}
      {- Subnormals are represented by ["[-]0x0.<f>p-1022"] where
         [<f>] is the significand bits in hexadecimal.}
      {- NaNs are represented by ["[-]nan(0x<p>)"] where [<p>] is the payload
         in hexadecimal.}
      {- Infinities and zeroes are represented by ["[-]inf"] and ["[-]0."].}}

      This format should be compatible with recent implementations of
      {{:http://www.opengroup.org/onlinepubs/000095399/functions/strtod.html}
      strtod} and hence with [float_of_string] (but negative NaNs seem to
      be problematic to get back). *)


  (** {1:floatrecall Quick recall on OCaml's [float]s}

     An OCaml [float] is an
     {{:http://ieeexplore.ieee.org/servlet/opac?punumber=4610933}IEEE-754}
     64 bit double precision binary floating point number. The 64 bits
     are laid out as follows :
{v
+----------------+-----------------------+-------------------------+
| sign s (1 bit) | exponent e (11 bits)  | significand t (52 bits) |
+----------------+-----------------------+-------------------------+
               63|62                   52|51                      0|
v}

    The value represented depends on s, e and t :
{v
sign   exponent       significand   value represented           meaning
-------------------------------------------------------------------------
s      0              0             -1^s * 0                    zero
s      0              t <> 0        -1^s * 0.t * 2^-1022        subnormal
s      0 < e < 2047   f             -1^s * 1.t * 2^(e - 1023)   normal
s      2047           0             -1^s * infinity             infinity
s      2047           t <> 0        NaN                         not a number
v}

     There are two zeros, a positive and a negative one but both are
     deemed equal by [=] and [Stdlib.compare]. A NaN is never equal
     (=) to {e itself} or to another NaN however [Stdlib.compare]
     asserts any NaN to be equal to itself and to any other NaN.

     The bit layout of a [float] can be converted to an [int64] and
     back using [Int64.bits_of_float] and [Int64.float_of_bits].

     The bit 51 of a NaN is used to distinguish between quiet (bit set)
     and signaling NaNs (bit cleared); the remaining 51 lower bits of
     the significand are the NaN's {e payload} which can be used to
     store diagnostic information. These features don't seem to used in
     OCaml.

     The significand of a floating point number is made of 53 binary
     digits (don't forget the implicit digit), this corresponds to
     log{_10}(2{^53}) ~ 16 {e decimal} digits.

     Only [float] values in the interval \][-2]{^52};2{^52}\[ may have
     a fractional part. {!Float.max_frac_float} is the greatest
     positive [float] with a fractional part.

     Any integer value in the interval \[[-2]{^53};2{^53}\] can be
     represented exactly by a [float] value.  {e Integer} arithmetic
     performed in this interval is exact.  {!Float.max_int_arith} is
     2{^53}. *)

end

(** {1:vectors Vectors}

   An n-dimensional {e vector} [v] is a sequence of n, zero indexed,
   floating point {e components}. We write [v]{_i} the ith component
   of a vector.

   The matrix types are defined here so that they can be used in vector
   modules; their modules are {{!matrices}here}. *)

type m2
(** The type for 2x2 matrices. *)

type m3
(** The type for 3x3 matrices. *)

type m4
(** The type for 4x4 matrices. *)


type v2
(** The type for 2D vectors. *)

type v3
(** The type for 3D vectors. *)

type v4
(** The type for 4D vectors. *)

(** Implemented by all vector types. *)
module type V = sig
  type t
  (** The type for vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!t}. *)

  type m
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations}
      of {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val comp : int -> t -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val zero : t
  (** [zero] is the neutral element for {!add}. *)

  val infinity : t
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : t
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> t
  (** [basis i] is the [i]th vector of an
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis}
      of the vector space {!t} with inner product {!dot}.

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  (** {1:functions Functions} *)

  val neg : t -> t
  (** [neg v] is the inverse vector [-v]. *)

  val add : t -> t -> t
  (** [add u v] is the vector addition [u + v]. *)

  val sub : t -> t -> t
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : t -> t -> t
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : t -> t -> t
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> t -> t
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : t -> t
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : t -> t -> float
  (** [dot u v] is the
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : t -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : t -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : t -> t
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : t -> t
  (** [homogene v] is the vector [v/(comp (dim - 1) v)] if
      [comp (dim - 1) v <> 0] and [v] otherwise. *)

  val mix : t -> t -> float -> t
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m -> t -> t
  (** [ltr m v] is the
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transform} [mv]. *)

  (** {1:ops Overridden [Stdlib] operators} *)

  val ( + ) : t -> t -> t
  (** [u + v] is [add u v]. *)

  val ( - ) : t -> t -> t
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> t -> t
  (** [t * v] is [smul t v]. *)

  val ( / ) : t -> float -> t
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> t -> t
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> t -> t
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> t -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> t -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> t -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  t -> unit
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> t -> bool
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> t -> bool
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : t -> t -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> t -> t -> int
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    t -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses
      [pp_comp] to print floating point values. *)
end

(** 2D vectors. *)
module V2 : sig
  type t = v2
  (** The type for 2D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v2}. *)

  type m = m2
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations} of 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> v2
  (** [v x y] is the vector [(x y)]. *)

  val comp : int -> v2 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val x : v2 -> float
  (** [x v] is the x component of [v].*)

  val y : v2 -> float
  (** [y v] is the y component of [v].*)

  val ox : v2
  (** [ox] is the unit vector [(1. 0.)]. *)

  val oy : v2
  (** [oy] is the unit vector [(0. 1.)]. *)

  val zero : v2
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v2
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v2
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v2
  (** [basis i] is the [i]th vector of an
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis}
      of the vector space {!t} with inner product {!dot}.

      Raises [Invalid_argument]x if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : float * float -> v2
  (** [of_tuple (x, y)] is [V2.v x y]. *)

  val to_tuple : v2 -> float * float
  (** [of_tuple v] is [(V2.x v, V2.y v]). *)

  val of_polar : v2 -> v2
  (** [of_polar pv] is a vector whose cartesian coordinates [(x, y)]
      correspond to the radial and angular
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinates} [(r, theta)] given by [(V2.x pv, V2.y pv)]. *)

  val to_polar : v2 -> v2
  (** [to_polar v] is a vector whose coordinates [(r, theta)] are the
      radial and angular
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinates} of [v]. [theta] is in \[[-pi;pi]\].*)

  val of_v3 : v3 -> v2
  (** [of_v3 u] is [v (V3.x u) (V3.y u)]. *)

  val of_v4 : v4 -> v2
  (** [of_v4 u] is [v (V4.x u) (V4.y u)]. *)

  (** {1:functions Functions} *)

  val neg : v2 -> v2
  (** [neg v] is the inverse vector [-v]. *)

  val add : v2 -> v2 -> v2
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v2 -> v2 -> v2
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v2 -> v2 -> v2
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v2 -> v2 -> v2
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v2 -> v2
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v2 -> v2
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : v2 -> v2 -> float
  (** [dot u v] is the
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v2 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v2 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v2 -> v2
  (** [unit v] is the unit vector [v/|v|]. *)

  val polar : float -> float -> v2
  (** [polar r theta] is [V2.of_polar (V2.v r theta)]. *)

  val angle : v2 -> float
  (** [angle v] is the angular
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinates} of [v]. The result is in \[[-pi;pi]\]. *)

  val ortho : v2 -> v2
  (** [ortho v] is [v] rotated by [pi] / 2. *)

  val homogene : v2 -> v2
  (** [homogene v] is the vector [v/v]{_y} if [v]{_y}[ <> 0] and [v]
      otherwise. *)

  val mix : v2 -> v2 -> float -> v2
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m2 -> v2 -> v2
  (** [ltr m v] is the
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transform} [mv]. *)

  val tr : m3 -> v2 -> v2
  (** [tr m v] is the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 2D space of the {e vector} [v] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [v] is treated as a vector
      (infinite point, its last coordinate in homogenous space is 0)
      and is thus translationally invariant. Use {!P2.tr} to
      transform finite points. *)

  (** {1:ops Overridden [Stdlib] operators} *)

  val ( + ) : v2 -> v2 -> v2
  (** [u + v] is [add u v]. *)

  val ( - ) : v2 -> v2 -> v2
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> v2 -> v2
  (** [t * v] is [smul t v]. *)

  val ( / ) : v2 -> float -> v2
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v2 -> v2
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v2 -> v2
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v2 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v2 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v2 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v2 -> unit
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> v2 -> bool
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v2 -> bool
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v2 -> v2 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v2 -> v2 -> bool
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v2 -> v2 -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> v2 -> v2 -> int
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> v2 -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    v2 -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses
      [pp_comp] to print floating point values. *)
end

(** 3D vectors. *)
module V3 : sig
  type t = v3
  (** The type for 3D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v3}. *)

  type m = m3
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations}
      of 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> v3
  (** [v x y z] is the vector [(x y z)]. *)

  val comp : int -> v3 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val x : v3 -> float
  (** [x v] is the x component of [v]. *)

  val y : v3 -> float
  (** [y v] is the y component of [v]. *)

  val z : v3 -> float
  (** [z v] is the z component of [v]. *)

  val ox : v3
  (** [ox] is the unit vector [(1. 0. 0.)]. *)

  val oy : v3
  (** [oy] is the unit vector [(0. 1. 0.)]. *)

  val oz : v3
  (** [oz] is the unit vector [(0. 0. 1.)]. *)

  val zero : v3
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v3
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v3
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v3
  (** [basis i] is the [i]th vector of an
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis}
      of the vector space {!t} with inner product {!dot}.

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : (float * float * float) -> v3
  (** [of_tuple (x, y, z)] is [v x y z]. *)

  val to_tuple : v3 -> (float * float * float)
  (** [to_tuple v] is [(x v, y v, z v)]. *)

  val of_spherical : v3 -> v3
  (** [of_spherical sv] is the vector whose cartesian coordinates
      [(x, y, z)] correspond to the radial, azimuth
      angle and zenith angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} [(r, theta, phi)] given by [(V3.x sv, V2.y sv, V3.z sv)]. *)

  val to_spherical : v3 -> v3
  (** [to_spherical v] is the vector whose coordinate [(r, theta,
      phi)] are the radial, azimuth angle and zenith angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} of [v]. [theta] is in \[[-pi;pi]\] and [phi] in
      \[[0;pi]\]. *)

  val of_v2 : v2 -> z:float -> v3
  (** [of_v2 u z] is [v (V2.x u) (V2.y u) z]. *)

  val of_v4 : v4 -> v3
  (** [of_v4 u z] is [v (V4.x u) (V4.y u) (V4.z u)]. *)

  (** {1:functions Functions} *)

  val neg : v3 -> v3
  (** [neg v] is the inverse vector [-v]. *)

  val add : v3 -> v3 -> v3
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v3 -> v3 -> v3
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v3 -> v3 -> v3
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v3 -> v3 -> v3
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v3 -> v3
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v3 -> v3
  (** [half v] is the half vector [smul 0.5 v]. *)

  val cross : v3 -> v3 -> v3
  (** [cross u v] is the
      {{:http://mathworld.wolfram.com/CrossProduct.html}cross product}
      [u x v]. *)

  val dot : v3 -> v3 -> float
  (** [dot u v] is the
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v3 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v3 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v3 -> v3
  (** [unit v] is the unit vector [v/|v|]. *)

  val spherical : float -> float -> float -> v3
  (** [spherical r theta phi] is [of_spherical (V3.v r theta phi)]. *)

  val azimuth : v3 -> float
  (** [azimuth v] is the azimuth angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} of [v]. The result is in \[[-pi;pi]\]. *)

  val zenith : v3 -> float
  (** [zenith v] is the zenith angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} of [v]. The result is in \[[0;pi]\]. *)

  val homogene : v3 -> v3
  (** [homogene v] is the vector [v/v]{_z} if [v]{_z}[ <> 0] and
      [v] otherwise. *)

  val mix : v3 -> v3 -> float -> v3
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m3 -> v3 -> v3
  (** [ltr m v] is the
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transform} [mv]. *)

  val tr : m4 -> v3 -> v3
  (** [tr m v] is the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 3D space of the {e vector} [v] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [v] is treated as a vector
      (infinite point, its last coordinate in homogenous space is 0)
      and is thus translationally invariant. Use {!P3.tr} to
      transform finite points. *)

  (** {1:ops Overridden [Stdlib] operators} *)

  val ( + ) : v3 -> v3 -> v3
  (** [u + v] is [add u v]. *)

  val ( - ) : v3 -> v3 -> v3
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> v3 -> v3
  (** [t * v] is [smul t v]. *)

  val ( / ) : v3 -> float -> v3
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v3 -> v3
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v3 -> v3
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v3 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v3 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v3 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v3 -> unit
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> v3 -> bool
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v3 -> bool
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v3 -> v3 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v3 -> v3 -> bool
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v3 -> v3 -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> v3 -> v3 -> int
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> v3 -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    v3 -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses
      [pp_comp] to print floating point values. *)
end

(** 4D vectors. *)
module V4 : sig
  type t = v4
  (** The type for 4D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v4}. *)

  type m = m4
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations}
      of 4D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float -> v4
  (** [v x y z w] is the vector [(x y z w)]. *)

  val comp : int -> v4 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val x : v4 -> float
  (** [x v] is the x component of [v]. *)

  val y : v4 -> float
  (** [y v] is the y component of [v]. *)

  val z : v4 -> float
  (** [z v] is the z component of [v]. *)

  val w : v4 -> float
  (** [z v] is the z component of [v]. *)

  val ox : v4
  (** [ox] is the unit vector [(1. 0. 0. 0.)]. *)

  val oy : v4
  (** [oy] is the unit vector [(0. 1. 0. 0.)]. *)

  val oz : v4
  (** [oz] is the unit vector [(0. 0. 1. 0.)]. *)

  val ow : v4
  (** [ow] is the unit vector [(0. 0. 0. 1.)]. *)

  val zero : v4
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v4
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v4
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v4
  (** [basis i] is the [i]th vector of an
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis}
      of the vector space {!t} with inner product {!dot}.

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : (float * float * float * float) -> v4
  (** [of_tuple (x, y, z, w)] is [v x y z w]. *)

  val to_tuple : v4 -> (float * float * float * float)
  (** [to_tuple v] is [(x v, y v, z v, w v)]. *)

  val of_v2 : v2 -> z:float -> w:float -> v4
  (** [of_v2 u z w] is [v (V2.x u) (V2.y u) z w]. *)

  val of_v3 : v3 -> w:float -> v4
  (** [of_v3 u w] is [v (V3.x u) (V3.y u) (V3.z u) w]. *)

  (** {1:functions Functions} *)

  val neg : v4 -> v4
  (** [neg v] is the inverse vector [-v]. *)

  val add : v4 -> v4 -> v4
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v4 -> v4 -> v4
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v4 -> v4 -> v4
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v4 -> v4 -> v4
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v4 -> v4
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v4 -> v4
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : v4 -> v4 -> float
  (** [dot u v] is the
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v4 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v4 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v4 -> v4
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : v4 -> v4
  (** [homogene v] is the vector [v/v]{_w} if [v]{_w}[ <> 0] and [v]
      otherwise. *)

  val mix : v4 -> v4 -> float -> v4
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m4 -> v4 -> v4
  (** [ltr m v] is the
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transform} [mv]. *)

  (** {1:ops Overridden [Stdlib] operators} *)

  val ( + ) : v4 -> v4 -> v4
  (** [u + v] is [add u v]. *)

  val ( - ) : v4 -> v4 -> v4
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> v4 -> v4
  (** [t * v] is [smul t v]. *)

  val ( / ) : v4 -> float -> v4
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v4 -> v4
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v4 -> v4
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v4 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v4 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v4 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v4 -> unit
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> v4 -> bool
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v4 -> bool
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v4 -> v4 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v4 -> v4 -> bool
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v4 -> v4 -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> v4 -> v4 -> int
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> v4 -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    v4 -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses
      [pp_comp] to print floating point values. *)
end

(** {1:points Points}

    An n-dimensional {e point} [p] is a vector of the corresponding
    dimension. The components of the vector are the point's {e
    coordinates}.
*)

type p2 = v2
(** The type for 2D points. *)

type p3 = v3
(** The type for 3D points. *)

(** Implemented by all point types. *)
module type P = sig
  type t
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!t}. *)

  type mh
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val o : t
  (** [o] is the point whose coordinates are all zero. *)

  (** {1:functions Functions} *)

  val mid : t -> t -> t
  (** [mid p q] is the mid point [(p + q)/2]. *)

  val tr : mh -> t -> t
  (** [tr m p] is the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} {!dim} space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point
      (its last coordinate in homogenous space is 1). *)
end

(** 2D points. *)
module P2 : sig
  type t = p2
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!p2}. *)

  type mh = m3
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> p2
  (** [v x y] is the point [(x y)]. *)

  val x : p2 -> float
  (** [x p] is the x coordinate of [p].*)

  val y : p2 -> float
  (** [y p] is the y coordinate of [p].*)

  val o : p2
  (** [o] is the point [(0 0)]. *)

  (** {1:functions Functions} *)

  val mid : p2 -> p2 -> p2
  (** [mid p q] is the mid point [(p + q)/2]. *)

  val tr : m3 -> p2 -> p2
  (** [tr m p] is the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 2D space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point
      (its last coordinate in homogenous space is 1). Use {!V2.tr}
      to transform vectors (infinite points). *)

  val orient : p2 -> p2 -> p2 -> float
  (** [orient p q r] is:
      - [> 0.] if the sequence [p], [q], [r] is in counterclockwise order.
        [r] is on the left of the line [pq].
      - [< 0.] if the sequence [p], [q], [r] is in clockwise order.
        [r] is on the right of line [pq].
      - [= ±0.] if [p], [q] and [r] are collinear. [r] is on [pq].

      Incidentally this is the signed area of the parallelogram
      spanned by vectors [pr] and [qr], which is twice the signed area of
      the triangle [pqr]. *)

  val seg_inter :
    ?eps2:float -> p0:p2 -> p1:p2 -> q0:p2 -> q1:p2 -> unit ->
    [ `None | `Pt of p2 | `Seg of p2 * p2 ]
    (** [seg_inter ~p0 ~p1 ~q0 ~q1 ()] is the intersection between
        segments [p0p1] and [q0q1]. This is:

        - [`None] if the segments do not intersect.
        - [`Pt i] if they intersect on the single point [i].
        - [`Seg (i0, i1)] if they intersect on the segment [i0i1].

        [eps2] is a squared relative epsilon. It is used as a
        threshold for testing the zeroness of the angle between the
        segments. Defaults to [1e-8]. *)
end

(** 3D points. *)
module P3 : sig
  type t = p3
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!p3}. *)

  type mh = m4
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> p3
  (** [v x y z] is the point [(x y z)]. *)

  val x : p3 -> float
  (** [x p] is the x coordinate of [p].*)

  val y : p3 -> float
  (** [y p] is the y coordinate of [p].*)

  val z : p3 -> float
  (** [y p] is the z coordinate of [p].*)

  val o : p3
  (** [o] is the point [(0 0 0)]. *)

  (** {1:functions Functions} *)

  val mid : p3 -> p3 -> p3
  (** [mid p q] is the mid point [(p + q)/2]. *)

  val tr : m4 -> p3 -> p3
  (** [tr m p] is the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 3D space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point
      (its last coordinate in homogenous space is 1). Use {!V3.tr}
      to transform vectors (infinite points). *)
end

(** {1:quaternions Quaternions}

    Unit {{:http://mathworld.wolfram.com/Quaternion.html}quaternions}
    represent rotations in 3D space. They allow to smoothly
    interpolate between orientations. A quaternion is a 4D vector,
    whose components [x], [y], [z], [w] represents the quaternion
    [x]i+ [y]j + [z]k + [w]. *)

type quat = v4
(** The type for quaternions. *)

(** Quaternions. *)
module Quat : sig

  type t = quat
  (** The type for quaternions. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float -> quat
  (** [v x y z w] is the quaternion [x]i+ [y]j + [z]k + [w]. *)

  val zero : quat
  (** [zero] is the zero quaternion. *)

  val id : quat
  (** [id] is the identity quaternion [1]. *)

  (** {1:functions Functions} *)

  val mul : quat -> quat -> quat
  (** [mul q r] is the quaternion multiplication [q * r]. *)

  val conj : quat -> quat
  (** [conj q] is the
      {{:http://mathworld.wolfram.com/QuaternionConjugate.html}quaternion
      conjugate} [q*]. *)

  val unit : quat -> quat
  (** [unit q] is the unit vector [q/|q|] (same as {!V4.unit}). *)

  val inv : quat -> quat
  (** [inv q] is the quaternion inverse [q]{^ -1}. *)

  val slerp : quat -> quat -> float -> quat
  (** [slerp q r t] is the spherical linear interpolation between [q]
      and [r] at [t]. Non commutative, torque minimal and constant
      velocity. *)

  val squad : quat -> quat -> quat -> quat -> float -> quat
  (** [squad q cq cr r t] is the spherical cubic interpolation
      between [q] and [r] at [t]. [cq] and [cr] indicate the tangent
      orientations at [q] and [r]. *)

  val nlerp : quat -> quat -> float -> quat
  (** [nlerp q r t] is the normalized linear interpolation between [q]
      and [r] at [t].  Commutative, torque minimal and inconstant
      velocity. *)

  (** {1:transformations3d 3D space transformations} *)

  val of_m3 : m3 -> quat
  (** [of_m3 m] is the unit quaternion for the rotation in [m]. *)

  val of_m4 : m4 -> quat
  (** [of_m4 m] is the unit quaternion for the rotation in the 3x3
      top left matrix in [m]. *)

  val rot3_map : v3 -> v3 -> quat
  (** Unit quaternion for the rotation, see {!M3.rot3_map}. *)

  val rot3_axis : v3 -> float -> quat
  (** Unit quaternion for the rotation, see {!M3.rot3_axis}. *)

  val rot3_zyx : v3 -> quat
  (** Unit quaternion for the rotation, see {!M3.rot3_zyx}. *)

  val to_rot3_axis : quat -> v3 * float
  (** [to_rot3_axis q] is the rotation axis and angle in radians of the {e
      unit} quaternion [q].*)

  val to_rot3_zyx : quat -> v3
  (** [to_rot_zyx q] is the x, y, z axis angles in radians of the {e unit}
      quaternion [q]. *)

  val apply3 : quat -> v3 -> v3
  (** [apply3 q v] applies the 3D rotation of the {e unit} quaternion
      [q] to the vector (or point) [v]. *)

  val apply4 : quat -> v4 -> v4
  (** [apply4 q v] apply the 3D rotation of the {e unit} quaternion
      [q] to the homogenous vector (or point) [v]. *)
end

(** {1:matrices Matrices}

    An {e m}x{e n} matrix [a] is an array of {e m} rows and {e n}
    columns of floating point {e elements}. We write [a]{_ij} the
    element of [a] located at the ith row and jth column.

    Matrix constructors specify matrix elements in
    {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order}
    so that matrix definitions look mathematically natural with proper
    code indentation. However elements are {e stored} and {e
    iterated} over in
    {{:http://en.wikipedia.org/wiki/Column-major_order}column-major
    order}. *)

(** Implemented by all (square) matrix types. *)
module type M = sig
  type t
  (** The type for matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val el : int -> int -> t -> float
  (** [el i j a] is the element [a]{_[ij]}.

      Raises [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)


  val row : int -> t -> v
  (** [row i a] is the [i]th row of [a].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> t -> v
  (** [col j a] is the [j]th column of [a].

      Raises [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : t
  (** [zero] is the neutral element for {!add}. *)

  val id : t
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  (** {1:functions Functions} *)

  val neg : t -> t
  (** [neg a] is the negated matrix [-a]. *)

  val add : t -> t -> t
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : t -> t -> t
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : t -> t -> t
  (** [mul a b] is the
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix
      multiplication} [a * b]. *)

  val emul : t -> t -> t
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : t -> t -> t
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> t -> t
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : t -> t
  (** [transpose a] is the
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : t -> float
  (** [trace a] is the
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace}
      [trace(a)]. *)

  val det : t -> float
  (** [det a] is the
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *)

  val inv : t -> t
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> t -> t
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> t -> t
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> t -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> t -> 'a
  (** [foldi f acc a] is
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> t -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  t -> unit
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> t -> bool
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> t -> bool
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : t -> t -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare a b] is [Stdlib.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> t -> t -> int
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    t -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses
      [pp_e] to print floating point values. *)
end

(** 2D square matrices. *)
module M2 : sig
  type t = m2
  (** The type for 2D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v2
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float ->
          float -> float -> m2
  (** [v e00 e01 e10 e11] is a matrix whose components are
      specified in
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v2 -> v2 -> m2
  (** [of_rows r0 r1] is the matrix whose rows are [r0] and [r1]. *)

  val of_cols : v2 -> v2 -> m2
  (** [of_cols c0 c1] is the matrix whose columns are [c0] and [c1]. *)

  val el : int -> int -> m2 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      Raises [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m2 -> v2
  (** [row i a] is the [i]th row of [a].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m2 -> v2
  (** [col j a] is the [j]th column of [a].

      Raises [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m2
  (** [zero] is the neutral element for {!add}. *)

  val id : m2
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m3 : m3 -> m2
  (** [of_m3 m] extracts the 2D linear part (top-left 2x2 matrix) of [m]. *)

  val of_m4 : m4 -> m2
  (** [of_m4 m] extracts the 2D linear part (top-left 2x2 matrix) of [m]. *)

  (** {1:functions Functions} *)

  val neg : m2 -> m2
  (** [neg a] is the negated matrix [-a]. *)

  val add : m2 -> m2 -> m2
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m2 -> m2 -> m2
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m2 -> m2 -> m2
  (** [mul a b] is the
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix
      multiplication} [a * b]. *)

  val emul : m2 -> m2 -> m2
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m2 -> m2 -> m2
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m2 -> m2
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m2 -> m2
  (** [transpose a] is the
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m2 -> float
  (** [trace a] is the
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace}
      [trace(a)]. *)

  val det : m2 -> float
  (** [det a] is the
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *)

  val inv : m2 -> m2
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *)

  val rot2 : float -> m2
  (** [rot2 theta] rotates 2D space around the origin by [theta] radians. *)

  val scale2 : v2 -> m2
  (** [scale2 s] scales 2D space in the [x] and [y] dimensions
      according to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m2 -> m2
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m2 -> m2
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m2 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m2 -> 'a
  (** [foldi f acc a] is
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m2 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m2 -> unit
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> m2 -> bool
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m2 -> bool
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m2 -> m2 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m2 -> m2 -> bool
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m2 -> m2 -> int
  (** [compare a b] is [Stdlib.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m2 -> m2 -> int
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> m2 -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    m2 -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m2 -> float
  val e01 : m2 -> float
  val e10 : m2 -> float
  val e11 : m2 -> float
end

(** 3D square matrices. *)
module M3 : sig
  type t = m3
  (** The type for 3D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v3
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float ->
          float -> float -> float ->
          float -> float -> float -> m3
  (** [v e00 e01 e02 e10 e11 e12 e20 e21 e22] is a matrix whose components
      are specified in
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v3 -> v3 -> v3 -> m3
  (** [of_rows r0 r1 r2] is the matrix whose rows are [r0], [r1] and [r2]. *)

  val of_cols : v3 -> v3 -> v3 -> m3
  (** [of_cols c0 c1 c2] is the matrix whose columns are [c0], [c1] and [c2]. *)

  val el : int -> int -> m3 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      Raises [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m3 -> v3
  (** [row i a] is the [i]th row of [a].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m3 -> v3
  (** [col j a] is the [j]th column of [a].

      Raises [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m3
  (** [zero] is the neutral element for {!add}. *)

  val id : m3
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m2_v2 : m2 -> v2 -> m3
  (** [of_m2_v2 m v] is the matrix whose first two rows are
      those of [m],[v] side by side and the third is [0 0 1]. *)

  val of_m4 : m4 -> m3
  (** [of_m4 m] extracts the 3D linear part (top-left 3x3 matrix) of [m]. *)

  val of_quat : quat -> m3
  (** [of_quat q] is the rotation of the {e unit} quaternion [q] as
      3D matrix. *)

  (** {1:functions Functions} *)

  val neg : m3 -> m3
  (** [neg a] is the negated matrix [-a]. *)

  val add : m3 -> m3 -> m3
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m3 -> m3 -> m3
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m3 -> m3 -> m3
  (** [mul a b] is the
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix
      multiplication} [a * b]. *)

  val emul : m3 -> m3 -> m3
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m3 -> m3 -> m3
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m3 -> m3
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m3 -> m3
  (** [transpose a] is the
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m3 -> float
  (** [trace a] is the
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace}
      [trace(a)]. *)

  val det : m3 -> float
  (** [det a] is the
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *)

  val inv : m3 -> m3
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *)

  val move2 : v2 -> m3
  (** [move2 d] translates 2D space in the x and y dimensions according
      to [d]. *)

  val rot2 : ?pt:p2 -> float -> m3
  (** [rot2 pt theta] rotates 2D space around the point [pt] by [theta]
      radians. [pt] defaults to {!P2.o}. *)

  val scale2 : v2 -> m3
  (** See {!M2.scale2}. *)

  val rigid2 : move:v2 -> rot:float -> m3
  (** [rigid2 move theta] is the rigid body transformation of
      2D space that rotates by [theta] radians and then translates by [move]. *)

  val srigid2 : move:v2 -> rot:float -> scale:v2 -> m3
  (** [srigid2 move theta scale] is like {!rigid2} but starts by
      scaling according to [scale]. *)

  (** {1:transformations3d 3D space transformations} *)

  val rot3_map : v3 -> v3 -> m3
  (** [rot3_map u v] rotates 3D space to map the {e unit} vector [u] on
      the {e unit} vector [v]. *)

  val rot3_axis : v3 -> float -> m3
  (** [rot_axis v theta] rotates 3D space by [theta] radians around
      the {e unit} vector [v]. *)

  val rot3_zyx : v3 -> m3
  (** [rot3_zyx r] rotates 3D space first by [V3.x r] radians around
      the x-axis, then by [V3.y r] radians around the y-axis and
      finally by [V3.z r] radians around the z-axis. *)

  val scale3 : v3 -> m3
  (** [scale3 s] scales 3D space in the [x], [y] and [z] dimensions
      according to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m3 -> m3
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m3 -> m3
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m3 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m3 -> 'a
  (** [foldi f acc a] is
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m3 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m3 -> unit
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> m3 -> bool
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m3 -> bool
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m3 -> m3 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m3 -> m3 -> bool
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m3 -> m3 -> int
  (** [compare a b] is [Stdlib.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m3 -> m3 -> int
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> m3 -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    m3 -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m3 -> float
  val e01 : m3 -> float
  val e02 : m3 -> float
  val e10 : m3 -> float
  val e11 : m3 -> float
  val e12 : m3 -> float
  val e20 : m3 -> float
  val e21 : m3 -> float
  val e22 : m3 -> float
end

(** 4D square matrices. *)
module M4 : sig
  type t = m4
  (** The type for 4D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v4
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float ->
          float -> float -> float -> float ->
          float -> float -> float -> float ->
          float -> float -> float -> float -> m4
  (** [v e00 e01 e02 e03 e10 e11 e12 e13 e20 e21 e22 e23 e30 e31 e32 e33]
      is a matrix whose components are specified in
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v4 -> v4 -> v4 -> v4 -> m4
  (** [of_rows r0 r1 r2 r3] is the matrix whose rows are [r0], [r1], [r2] and
      [r3]. *)

  val of_cols : v4 -> v4 -> v4 -> v4 -> m4
  (** [of_cols c0 c1 c2 c3] is the matrix whose columns are [c0], [c1], [c2]
      and [c3]. *)

  val el : int -> int -> m4 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      Raises [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m4 -> v
  (** [row i a] is the [i]th row of [a].

      Raises [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m4 -> v
  (** [col j a] is the [j]th column of [a].

      Raises [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m4
  (** [zero] is the neutral element for {!add}. *)

  val id : m4
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m3_v3 : m3 -> v3 -> m4
  (** [of_m3_v3 m v] is the matrix whose first three rows are
      those of [m],[v] side by side and the fourth is [0 0 0 1]. *)

  val of_quat : quat -> m4
  (** [to_quat q] is the rotation of the {e unit} quaternion [q] as
      4D matrix. *)

  (** {1:functions Functions} *)

  val neg : m4 -> m4
  (** [neg a] is the negated matrix [-a]. *)

  val add : m4 -> m4 -> m4
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m4 -> m4 -> m4
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m4 -> m4 -> m4
  (** [mul a b] is the
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix
      multiplication} [a * b]. *)

  val emul : m4 -> m4 -> m4
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m4 -> m4 -> m4
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m4 -> m4
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m4 -> m4
  (** [transpose a] is the
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m4 -> float
  (** [trace a] is the
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace}
      [trace(a)]. *)

  val det : m4 -> float
  (** [det a] is the
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *)

  val inv : m4 -> m4
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *)

  val move2 : v2 -> m4
  (** See {!M3.move2}. *)

  val rot2 : ?pt:p2 -> float -> m4
  (** See {!M3.rot2}. *)

  val scale2 : v2 -> m4
  (** See {!M2.scale2}. *)

  val rigid2 : move:v2 -> rot:float -> m4
  (** See {!M3.rigid2}. *)

  val srigid2 : move:v2 -> rot:float -> scale:v2 -> m4
  (** See {!M3.srigid2}. *)

  (** {1:transformations3d 3D space transformations} *)

  val move3 : v3 -> m4
  (** [move d] translates 3D space in the x, y and z dimensions according
      to [d]. *)

  val rot3_map : v3 -> v3 -> m4
  (** See {!M3.rot3_map}. *)

  val rot3_axis : v3 -> float -> m4
  (** See {!M3.rot3_axis}. *)

  val rot3_zyx : v3 -> m4
  (** See {!M3.rot3_zyx}. *)

  val scale3 : v3 -> m4
  (** See {!M3.scale3}. *)

  val rigid3 : move:v3 -> rot:v3 * float -> m4
  (** [rigid3 move rot] is the rigid body transformation
      of 3D space that rotates by the axis/radian angle [rot]
      and then translates by [move]. *)

  val rigid3q : move:v3 -> rot:quat -> m4
  (** [rigid3q move rot] is the rigid body transformation of 3D space
      that rotates by the quaternion [rot] and then translates by
      [move]. *)

  val srigid3 : move:v3 -> rot:v3 * float -> scale:v3 -> m4
  (** [srigid3 scale move rot scale] is like {!rigid3} but starts
      by scaling according to [scale]. *)

  val srigid3q : move:v3 -> rot:quat -> scale:v3 -> m4
  (** [srigid3q move rot scale] is like {!rigid3q} but starts by scaling
      according to [scale]. *)

(** {1:projections3d 3D space projections}

    Projection matrices assume a right-handed coordinate
    system with the eye at the origin looking down the z-axis. *)

  val ortho : left:float -> right:float -> bot:float -> top:float ->
    near:float -> far:float -> m4
  (** [ortho left right bot top near far] maps the axis aligned box with
      corners [(left, bot, -near)] and [(right, top, -far)] to
      the axis aligned cube with corner [(-1, -1, -1)] and [(1, 1, 1)]. *)

  val persp : left:float -> right:float -> bot:float -> top:float ->
    near:float -> far:float -> m4
  (** [persp left right bot top near far] maps the frustum with top of
      the underlying pyramid at the origin, near clip rectangle corners
      [(left, bot, -near)], [(right, top, -near)] and far plane at
      [-far] to the axis aligned cube with corners [(-1, -1, -1)] and
      [(1,1,1)]. *)

(*
     val persp_fov : fovy:float -> aspect:float -> near:float ->
     far:float -> m4
  (** Perspective projection. [fovy] is the field of view, in radians,
      along the y-axis.  [aspect] is the ratio [w/h] of the near clip
      rectangle. [near] and [far] are {e distances} to the near and
      far clip planes.

      Let [h = 2 * near * (tan fovy/2)] and [w = aspect * h]. The
      transform maps the {e symmetric} frustum with top of the
      underlying pyramid at the origin, near clip rectangle corners
      [(-w/2,-h/2,-near)], [(w/2,h/2,-near)] and far plane at
      [-far] to the cube with corners [(-1, -1, -1)] and [(1,1,1)]. *)
*)


  (** {1:transformations4d 4D space transformations} *)

  val scale4 : v4 -> m4
  (** [scale4 s] scales 4D space in the x, y, z and w dimensions according
      to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m4 -> m4
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m4 -> m4
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m4 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m4 -> 'a
  (** [foldi f acc a] is
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m4 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m4 -> unit
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)

  (** {1:preds Predicates and comparisons} *)

  val for_all : (float -> bool) -> m4 -> bool
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m4 -> bool
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m4 -> m4 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m4 -> m4 -> bool
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m4 -> m4 -> int
  (** [compare a b] is [Stdlib.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m4 -> m4 -> int
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> m4 -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    m4 -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m4 -> float
  val e01 : m4 -> float
  val e02 : m4 -> float
  val e03 : m4 -> float
  val e10 : m4 -> float
  val e11 : m4 -> float
  val e12 : m4 -> float
  val e13 : m4 -> float
  val e20 : m4 -> float
  val e21 : m4 -> float
  val e22 : m4 -> float
  val e23 : m4 -> float
  val e30 : m4 -> float
  val e31 : m4 -> float
  val e32 : m4 -> float
  val e33 : m4 -> float
end

(** {1:sizes Sizes}

    An n-dimensional {e size} [s] represents extents in n-dimensional space.
*)

type size1 = float
(** The type for sizes in 1D space. *)

type size2 = v2
(** The type for sizes in 2D space. *)

type size3 = v3
(** The type for sizes in 3D space. *)

(** Implemented by all size types. *)
module type Size = sig
  type t
  (** The type for sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!t}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val zero : t
  (** [zero] is the zero size, zero extent in each dimension. *)

  val unit : t
  (** [unit] is the unit size, one extent in each dimension. *)
end

(** Sizes in 1D space.

    In 1D space, {e width} is the extent along the x-axis. *)
module Size1 : sig
  type t = float
  (** The type for 1D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size1} *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> size1
  (** [v w] is a size of width [w]. *)

  val w : size1 -> float
  (** [w s] is the width of [s]. *)

  val zero : size1
  (** [zero] is the zero size, zero width. *)

  val unit : size1
  (** [unit] is the unit size, one width. *)
end

(** Sizes in 2D space.

    In 2D space, {e width} is the extent along the x-axis and
    {e height} the extent along the y-axis. *)
module Size2 : sig
  type t = size2
  (** The type for 2D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size2}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> size2
  (** [v w h] is a size of width [w] and height [h]. *)

  val w : size2 -> float
  (** [w s] is the width of [s]. *)

  val h : size2 -> float
  (** [h s] is the height of [s]. *)

  val zero : size2
  (** [zero] is the zero size, zero width and height. *)

  val unit : size2
  (** [unit] is the unit size, one width and height. *)

  (** {1:functions Functions} *)

  val aspect : size2 -> float
  (** [aspect s] is [w s /. h s]. *)

  val of_w : float -> aspect:float -> size2
  (** [of_w w aspect] is [v w (w /. aspect)]. *)

  val of_h : float -> aspect:float -> size2
  (** [of_h h aspect] is [v (h *. aspect) h]. *)
end

(** Sizes in 3D spaces.

    In 3D space, {e width} is the extent along the x-axis,
    {e height} the extent along the y-axis and {e depth}
    the extent along the z-axis. *)
module Size3 : sig

  type t = size3
  (** The type for 3D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size3}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> size3
  (** [v w h d] is a size of width [w], height [h] and depth [d]. *)

  val w : size3 -> float
  (** [w s] is the width of [s]. *)

  val h : size3 -> float
  (** [h s] is the height of [s]. *)

  val d : size3 -> float
  (** [d s] is the depth of [s]. *)

  val zero : size3
  (** [zero] is the zero size, zero width, height and depth. *)

  val unit : size3
  (** [unit] is the unit size, one width, height and depth. *)
end

(** {1:aboxes Axis-aligned boxes}

    An n-dimensional axis-aligned box [b] is defined by an
    n-dimensional point [o], its {e origin}, and an n-dimensional size
    [s]. Operations on boxes with negative sizes are undefined.

    The space S([b]) spanned by [b] is \[[o]{_0};
    [o]{_0} + [s]{_0}\] x ... x \[[o]{_n-1}; [o]{_n-1} +
    [s]{_n-1}\]. The extremum points of this space are the box's {e
    corners}. There is a distinguished n-dimensional [empty] box such
    that S([empty]) is empty.  *)

type box1
(** The type for 1D axis-aligned boxes
    ({{:http://mathworld.wolfram.com/Interval.html}closed intervals}). *)

type box2
(** The type for 2D axis-aligned boxes
    ({{:http://mathworld.wolfram.com/Rectangle.html}rectangles}). *)

type box3
(** The type for 3D axis-aligned boxes
    ({{:http://mathworld.wolfram.com/Cuboid.html}cuboids}). *)

(** Implemented by all axis-aligned box types. *)
module type Box = sig
  type t
  (** The type for boxes. *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!t}. *)

  type v
  (** The type for {!dim} vectors. *)

  type p
  (** The type for {!dim} points. *)

  type size
  (** The type for {!dim} sizes. *)

  type m
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations}
      of {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p -> size -> t
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : p -> size -> t
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and
      size is [size]. *)

  val empty : t
  (** [empty] is {e the} empty box. *)

  val o : t -> p
  (** [o b] is the origin of [b].

      Raises [Invalid_argument] on {!empty} *)

  val size : t -> size
  (** [size b] is the size of [b].

      Raises [Invalid_argument] on {!empty} *)

  val zero : t
  (** [zero] is a box whose origin and size is zero. *)

  val unit : t
  (** [unit] is the unit box which extends from zero to
      one in all dimensions. *)

  val of_pts : p -> p -> t
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  val add_pt : t -> p -> t
  (** [add_pt b p] is the smallest box whose space contains [b] and [p]. *)

  (** {1:functions Functions} *)

  val min : t -> p
  (** [min b] is the smallest point of [b] (its origin).

      Raises [Invalid_argument] on {!empty} *)

  val max : t -> p
  (** [max b] is the greatest point of [b] (its size added to the origin).

      Raises [Invalid_argument] on {!empty} *)

  val mid : t -> p
  (** [mid b] is the mid point between [min] and [max].

      Raises [Invalid_argument] on {!empty} *)

  val area : t -> float
  (** [area b] is the surface area of [b]. *)

  val inter : t -> t -> t
  (** [inter b b'] is a box whose space is the intersection of S([b])
      and S([b']). *)

  val union : t -> t -> t
  (** [union b b'] is the smallest box whose space contains
      S([b]) and S([b']). *)

  val inset : v -> t -> t
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the size in dimension [i] becomes negative it is clamped to [0]
      and the [i]th coordinate of the mid point of [b] is used for the
      [i]th coordinate of the resulting box's origin.  Returns
      {!empty} on {!empty}. *)

  val outset : v -> t -> t
  (** [outset d b] is [inset -d b]. *)

  val round : t -> t
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v -> t -> t
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m -> t -> t
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> t -> t
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1:preds Predicates and comparisons} *)

  val is_empty : t -> bool
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : t -> bool
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val isects : t -> t -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : t -> t -> bool
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p -> t -> bool
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : t -> t -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> t -> t -> int
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    t -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses
      [pp_fl] to print floating point values. *)
end

(** 1D axis-aligned boxes. *)
module Box1 : sig

  type t = box1
  (** The type for 1D boxes
      ({{:http://mathworld.wolfram.com/Interval.html}closed intervals}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box2}. *)

  type v = float
  (** The type for 1D vectors. *)

  type p = float
  (** The type for 1D points. *)

  type size = size1
  (** The type for 1D sizes. *)

  type m = float
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations}
      of 1D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> size1 -> box1
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : float -> size1 -> box1
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and
      size is [size]. *)

  val empty : box1
  (** [empty] is {e the} empty box. *)

  val o : box1 -> float
  (** [o b] is the origin of [b].

      Raises [Invalid_argument] on {!empty} *)

  val ox : box1 -> float
  (** [ox b] is [o b]. *)

  val size : box1 -> size1
  (** [size b] is the size of [b].

      Raises [Invalid_argument] on {!empty} *)

  val w : box1 -> float
  (** [w b] is [size b]. *)

  val zero : box1
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box1
  (** [unit] is the unit box which extends from zero to
      one in all dimensions. *)

  val of_pts : float -> float -> box1
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  val add_pt : box1 -> float -> box1
  (** [add_pt b p] is the smallest box whose space contains [b] and [p]. *)

  (** {1:functions Functions} *)

  val min : box1 -> float
  (** [min b] is the smallest point of [b] (its origin).

      Raises [Invalid_argument] on {!empty} *)

  val minx : box1 -> float
  (** [minx b] is [min b]. *)

  val max : box1 -> float
  (** [max b] is the greatest point of [b] (its size added to the origin).

      Raises [Invalid_argument] on {!empty} *)

  val maxx : box1 -> float
  (** [maxx b] is [max b]. *)

  val mid : box1 -> float
  (** [mid b] is the mid point between [min] and [max].

      Raises [Invalid_argument] on {!empty} *)

  val midx : box1 -> float
  (** [midx b] is [mid b]. *)

  val left : box1 -> float
  (** [left b] is [minx b]. *)

  val right : box1 -> float
  (** [right b] is [maxx b]. *)

  val area : box1 -> float
  (** [area b] is the surface area of [b]. *)

  val inter : box1 -> box1 -> box1
  (** [inter b b'] is a box whose space is the intersection of S([b])
      and S([b']). *)

  val union : box1 -> box1 -> box1
  (** [union b b'] is the smallest box whose space contains
      S([b]) and S([b']). *)

  val inset : float -> box1 -> box1
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the size in dimension [i] becomes negative it is clamped to [0]
      and the [i]th coordinate of the mid point of [b] is used for the
      [i]th coordinate of the resulting box's origin.  Returns
      {!empty} on {!empty}. *)

  val outset : float -> box1 -> box1
  (** [outset d b] is [inset (-d) b]. *)

  val round : box1 -> box1
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : float -> box1 -> box1
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : float -> box1 -> box1
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m2 -> box1 -> box1
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 1D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box1 -> box1
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1:preds Predicates and comparisons} *)

  val is_empty : box1 -> bool
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box1 -> bool
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val isects : box1 -> box1 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box1 -> box1 -> bool
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : float -> box1 -> bool
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box1 -> box1 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box1 -> box1 -> bool
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box1 -> box1 -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> box1 -> box1 -> int
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> box1 -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    box1 -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses
      [pp_fl] to print floating point values. *)
end

(** 2D axis-aligned boxes. *)
module Box2 : sig
  type t = box2
  (** The type for 2D boxes
      ({{:http://mathworld.wolfram.com/Rectangle.html}rectangles}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box2}. *)

  type v = v2
  (** The type for 2D vectors. *)

  type p = p2
  (** The type for 2D points. *)

  type size = size2
  (** The type for 2D sizes. *)

  type m = m2
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations} of 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p2 -> size2 -> box2
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : p2 -> size2 -> t
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and
      size is [size]. *)

  val empty : box2
  (** [empty] is {e the} empty box. *)

  val o : box2 -> p2
  (** [o b] is the origin of [b].

      Raises [Invalid_argument] on {!empty} *)

  val ox : box2 -> float
  (** [ox b] is [V2.x (o b)]. *)

  val oy : box2 -> float
  (** [oy b] is [V2.y (o b)]. *)

  val size : box2 -> size
  (** [size b] is the size of [b].

      Raises [Invalid_argument] on {!empty} *)

  val w : box2 -> float
  (** [w b] is [Size2.w (size b)]. *)

  val h : box2 -> float
  (** [h b] is [Size2.h (size b)]. *)

  val zero : box2
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box2
  (** [unit] is the unit box which extends from zero to
      one in all dimensions. *)

  val of_pts : p2 -> p2 -> box2
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  val add_pt : box2 -> p2 -> box2
  (** [add_pt b p] is the smallest box whose space contains [b] and [p]. *)

  (** {1:functions Functions} *)

  val min : box2 -> p2
  (** [min b] is the smallest point of [b] (its origin).

      Raises [Invalid_argument] on {!empty} *)

  val minx : box2 -> float
  (** [minx b] is [V2.x (min b)]. *)

  val miny : box2 -> float
  (** [miny b] is [V2.y (min b)]. *)

  val max : box2 -> p2
  (** [max b] is the greatest point of [b] (its size added to the origin).

      Raises [Invalid_argument] on {!empty} *)

  val maxx : box2 -> float
  (** [maxx b] is [V2.x (max b)]. *)

  val maxy : box2 -> float
  (** [maxy b] is [V2.y (max b)]. *)

  val mid : box2 -> p2
  (** [mid b] is the mid point between [min] and [max].

      Raises [Invalid_argument] on {!empty} *)

  val midx : box2 -> float
  (** [midx b] is [V2.x (mid b)]. *)

  val midy : box2 -> float
  (** [midy b] is [V2.y (mid b)]. *)

  val bl_pt : box2 -> p2
  (** [bl b] is the bottom-left corner of [b].

      Raises [Invalid_argument] on {!empty} *)

  val bm_pt : box2 -> p2
  (** [bm_pt b] is the bottom-mid point of [b].

      Raises [Invalid_argument] on {!empty} *)

  val br_pt : box2 -> p2
  (** [br_pt b] is the bottom-right corner of [b].

      Raises [Invalid_argument] on {!empty} *)

  val ml_pt : box2 -> p2
  (** [ml_pt b] is the mid-left corner of [b].

      Raises [Invalid_argument] on {!empty} *)

  val mm_pt : box2 -> p2
  (** [ml_pt b] is [{!mid} b].

      Raises [Invalid_argument] on {!empty} *)

  val mr_pt : box2 -> p2
  (** [mr_pt b] is the mid-right point of [b].

      Raises [Invalid_argument] on {!empty} *)

  val tl_pt : box2 -> p2
  (** [tl_pt b] is the top-left corner of [b].

      Raises [Invalid_argument] on {!empty} *)

  val tm_pt : box2 -> p2
  (** [tm_pt b] is the top-middle corner of [b].

      Raises [Invalid_argument] on {!empty} *)

  val tr_pt : box2 -> p2
  (** [tr_pt b] is the top-right corner of [b].

      Raises [Invalid_argument] on {!empty} *)

  val area : box2 -> float
  (** [area b] is the surface area of [b]. *)

  val inter : box2 -> box2 -> box2
  (** [inter b b'] is a box whose space is the intersection of S([b])
      and S([b']). *)

  val union : box2 -> box2 -> box2
  (** [union b b'] is the smallest box whose space contains
      S([b]) and S([b']). *)

  val inset : v2 -> box2 -> box2
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the size in dimension [i] becomes negative it is clamped to [0]
      and the [i]th coordinate of the mid point of [b] is used for the
      [i]th coordinate of the resulting box's origin.  Returns
      {!empty} on {!empty}. *)

  val outset : v2 -> box2 -> box2
  (** [outset d b] is [inset (V2.neg d) b]. *)

  val round : box2 -> box2
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v2 -> box2 -> box2
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m2 -> box2 -> box2
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m3 -> box2 -> box2
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 2D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box2 -> box2
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1:preds Predicates and comparisons} *)

  val is_empty : box2 -> bool
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box2 -> bool
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val is_seg : box2 -> bool
  (** [is_seg b] is [true] iff [b] is not {!empty} and its size is
      equal to 0 in exactly one dimension. *)

  val isects : box2 -> box2 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box2 -> box2 -> bool
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p2 -> box2 -> bool
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box2 -> box2 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box2 -> box2 -> bool
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box2 -> box2 -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> box2 -> box2 -> int
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> box2 -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    box2 -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses
      [pp_fl] to print floating point values. *)
end

(** 3D axis-aligned boxes. *)
module Box3 : sig
  type t = box3
  (** The type for 3D boxes
      ({{:http://mathworld.wolfram.com/Cuboid.html}cuboids}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box3}. *)

  type v = v3
  (** The type for 3D vectors. *)

  type p = p3
  (** The type for 3D points. *)

  type size = size3
  (** The type for 3D sizes. *)

  type m = m3
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear
      transformations} of 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p3 -> size3 -> box3
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : p3 -> size3 -> t
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and
      size is [size]. *)

  val empty : box3
  (** [empty] is {e the} empty box. *)

  val o : box3 -> p3
  (** [o b] is the origin of [b].

      Raises [Invalid_argument] on {!empty} *)

  val ox : box3 -> float
  (** [ox b] is [V3.x (o b)]. *)

  val oy : box3 -> float
  (** [oy b] is [V3.y (o b)]. *)

  val oz : box3 -> float
  (** [oz b] is [V3.z (o b)]. *)

  val size : box3 -> size3
  (** [size b] is the size of [b].

      Raises [Invalid_argument] on {!empty} *)

  val w : box3 -> float
  (** [w b] is [Size3.w (size b)]. *)

  val h : box3 -> float
  (** [h b] is [Size3.h (size b)]. *)

  val d : box3 -> float
  (** [d b] is [Size3.d (size b)]. *)

  val zero : box3
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box3
  (** [unit] is the unit box which extends from zero to
      one in all dimensions. *)

  val of_pts : p3 -> p3 -> box3
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  val add_pt : box3 -> p3 -> box3
  (** [add_pt b p] is the smallest box whose space contains [b] and [p]. *)

  (** {1:functions Functions} *)

  val min : box3 -> p3
  (** [min b] is the smallest point of [b] (its origin).

      Raises [Invalid_argument] on {!empty} *)

  val minx : box3 -> float
  (** [minx b] is [V3.x (min b)]. *)

  val miny : box3 -> float
  (** [miny b] is [V3.y (min b)]. *)

  val minz : box3 -> float
  (** [minz b] is [V3.z (min b)]. *)

  val max : box3 -> p3
  (** [max b] is the greatest point of [b] (its size added to the origin).

      Raises [Invalid_argument] on {!empty} *)

  val maxx : box3 -> float
  (** [maxx b] is [V3.x (max b)]. *)

  val maxy : box3 -> float
  (** [maxy b] is [V3.y (max b)]. *)

  val maxz : box3 -> float
  (** [maxz b] is [V3.z (max b)]. *)

  val mid : box3 -> p3
  (** [mid b] is the mid point between [min] and [max].

      Raises [Invalid_argument] on {!empty} *)

  val midx : box3 -> float
  (** [midx b] is [V3.x (mid b)]. *)

  val midy : box3 -> float
  (** [midy b] is [V3.y (mid b)]. *)

  val midz : box3 -> float
  (** [midz b] is [V3.z (mid b)]. *)

  val fbl_pt : box3 -> p3
  (** [fbl_pt b] is the far-bottom-left corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val fbr_pt : box3 -> p3
  (** [fbl_pt b] is the far-bottom-right corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val ftl_pt : box3 -> p3
  (** [fbl_pt b] is the far-top-left corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val ftr_pt : box3 -> p3
  (** [fbl_pt b] is the far-top-right corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val nbl_pt : box3 -> p3
  (** [nbl_pt b] is the near-bottom-left corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val nbr_pt : box3 -> p3
  (** [nbl_pt b] is the near-bottom-right corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val ntl_pt : box3 -> p3
  (** [nbl_pt b] is the near-top-left corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val ntr_pt : box3 -> p3
  (** [nbl_pt b] is the near-top-right corner of [b].
      Raises [Invalid_argument] on {!empty}. *)

  val area : box3 -> float
  (** [area b] is the surface area of [b]. *)

  val volume : box3 -> float
  (** [volume b] is the volume of [b]. *)

  val inter : box3 -> box3 -> box3
  (** [inter b b'] is a box whose space is the intersection of S([b])
      and S([b']). *)

  val union : box3 -> box3 -> box3
  (** [union b b'] is the smallest box whose space contains
      S([b]) and S([b']). *)

  val inset : v3 -> box3 -> box3
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the size in dimension [i] becomes negative it is clamped to [0]
      and the [i]th coordinate of the mid point of [b] is used for the
      [i]th coordinate of the resulting box's origin.  Returns
      {!empty} on {!empty}. *)

  val outset : v3 -> box3 -> box3
  (** [outset d b] is [inset (V3.neg d) b]. *)

  val round : box3 -> box3
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v3 -> box3 -> box3
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m3 -> box3 -> box3
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m4 -> box3 -> box3
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 3D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box3 -> box3
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1:preds Predicates and comparisons} *)

  val is_empty : box3 -> bool
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box3 -> bool
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val is_plane : box3 -> bool
  (** [is_plane b] is [true] iff the size of [b] is equal to 0 in exactly
      one dimension. *)

  val is_seg : box3 -> bool
  (** [is_seg b] is [true] iff [b] is not {!empty} and its size is
      equal to 0 in exactly two dimensions. *)

  val isects : box3 -> box3 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box3 -> box3 -> bool
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p3 -> box3 -> bool
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box3 -> box3 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box3 -> box3 -> bool
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box3 -> box3 -> int
  (** [compare u v] is [Stdlib.compare u v]. *)

  val compare_f : (float -> float -> int) -> box3 -> box3 -> int
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> box3 -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter ->
    box3 -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses
      [pp_fl] to print floating point values. *)
end

(** {1:colors Colors} *)

type color = v4
(** The type for colors, see  {{!Color.t}details}. *)

(** Colors and color profiles.

    [Color] provides some function to operate on {{!Color.t}color} values
    and basic support for ICC based {{!Color.profile}color profiles} to
    precisely specify how to interpret raw color samples.

    {3 References.}
    {ul
    {- Charles Poynton.
       {e {{:http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html}
       Frequently asked questions about color}}. 2006}
    {- Charles Poynton.
       {e {{:http://www.poynton.com/PDFs/Guided_tour.pdf}A guided tour of
       color space}}. 1997}
    {- Bruce MacEvoy.
       {{:http://www.handprint.com/LS/CVS/color.html}Color
       vision} and
      {{:http://www.handprint.com/HP/WCL/color7.html}modern color models}.}
    {- International Color Consortium.
       {e {{:http://www.color.org/icc_specs2.xalter}ICC.1:2010-12 Image
       technology colour management - Architecture, profile format, and
       data structure}}. 2010.}} *)
module Color : sig

  (** {1:colors Constructors, accessors and constants} *)

  type t = color
  (** The type for colors in a device independent RGB color space with
      an alpha component. The color space is defined by a D65 white
      point and the ITU-R BT.709 primaries (corresponds to a {e
      linearized}
      {{:http://www.color.org/chardata/rgb/srgb.xalter}sRGB} space).
      The {e alpha} component represent the color's opacity ranging
      from [0.], a fully transparent color, to [1.] a completly opaque
      one. *)

  type stops = (float * color) list
  (** The type for color stops. A piecewise linear color curve. *)

  val v : float -> float -> float -> float -> color
  (** [v r g b a] is the {e linear} sRGB color [(r, g, b, a)] as
      a color value. *)

  val v_srgb : ?a:float -> float -> float -> float -> color
  (** [v r g b ~a] is the sRGB color [(r, g, b, a)] converted to a
      [Gg] color value. *)

  val v_srgbi : ?a:float -> int -> int -> int -> color
  (** [v_srgbi r g b ~a] is the 24-bit sRGB color [(r, g, b, a)]
      converted to a [Gg] color value by [(v_srgb (float r /. 255.)
      (float g /. 255.)  (float b /. 255.) ~a]) *)

  val r : color -> float
  (** [r c] is the red component of [c]. *)

  val g : color -> float
  (** [g c] is the green component of [c]. *)

  val b : color -> float
  (** [b c] is the blue component of [c]. *)

  val a : color -> float
  (** [a c] is the alpha component of [c]. *)

  val void : color
  (** [void] is [(v 0. 0. 0. 0.)] an invisible color. *)

  val black : color
  (** [black] is [(v 0. 0. 0. 1.)] *)

  val gray : ?a:float -> float -> color
  (** [gray a g] is the sRGB color [(g, g, g, a)] converted to color a
      value. *)

  val white : color
  (** [white] is [(v 1. 1. 1. 1.)] *)

  val red : color
  (** [red] is [(v 1. 0. 0. 1.)] *)

  val green : color
  (** [green] is [(v 0. 1. 0. 1.)] *)

  val blue : color
  (** [blue] is [(v 0. 0. 1. 1.)] *)

  (** {1:functions Functions} *)

  val blend : color -> color -> color
  (** [blend src dst] is [src] blended over [dst] using
      source over destination alpha blending. See Alvy Ray Smith. {e
      {{:http://alvyray.com/Memos/MemosCG.htm#ImageCompositing}Image
       compositing fundamentals}}. 1995. *)

  val clamp : color -> color
  (** [clamp c] is [c] with all components clamped to \[[0;1]\]. [nan]
      components are left untouched. *)

  val with_a : color -> float -> color
  (** [with_a c a] is the same color as [c] but with the alpha
      component [a]. *)

  (** {1:conversions Color conversions}

      {b Note.} In the following conversions all color spaces carry an
      alpha component.  The alpha component is always left untouched
      by the conversions.

      {b WARNING.} Converting between color spaces may result in out
      of gamut colors whose components are out of the destination
      color space expected ranges. The client is responsible to handle
      these; for values of type {!color} simply {!clamp}ing these is
      one option. Currently some conversion do not even round trip
      due to floating point inaccuracies, see
      {{:https://github.com/dbuenzli/gg/issues/8}this issue}, so it is
      a good idea to {!clamp} the conversions to {!color}. *)

  (** {2:srgb sRGB} *)

  type srgb = v4
  (** The type for colors in the
     {{:http://www.color.org/chardata/rgb/srgb.xalter}sRGB} color space
     with an alpha component. This is the color space used, for example,
     by CSS. *)

  val of_srgb : srgb -> color
  (** [of_srgb c] is the sRGB color [c] as a [Gg] color. *)

  val to_srgb : color -> srgb
  (** [to_srgb c] is the [Gg] color [c] as a sRGB color. *)

  val to_srgbi : color -> (int * int * int * float)
  (** [to_srgbi c] is the [Gg] color [c] as a 24-bit sRGB color
      [(r, g, b, a)], see {!v_srgbi}. *)

  (** {2:luv CIE L*u*v*} *)

  type luv = v4
  (** The type for colors in the CIE L*u*v* color space with a D65 reference
      white point and an alpha component. The meaning and range of the
      components is:
      {ul
      {- L* is lightness in the range [0.] to [100.]}
      {- u*'s practical range is [-134.] to [220.]}
      {- v*'s practical range is [-140.] to [122.]}} *)

  val of_luv : luv -> color
  (** [of_luv c] is the L*u*v* color [c] as a [Gg] color. *)

  val to_luv : color -> luv
  (** [to_luv c] is the [Gg] color [c] as a L*u*v* color. *)

  (** {2:lch_uv CIE L*C*h{_uv}} *)

  type lch_uv = v4
  (** The type for colors in the CIE L*C*h{_uv} color space with a
      D65 reference white point and an alpha component. This color
      space is CIE L*u*v* with polar coordinates, the meaning and range
      of the components is:
     {ul
     {- L* is the lightness in the range [0.] to [100.]}
     {- C* represents chroma, in the range [0.] to [260.77] in practice.}
     {- h represents hue in radians in the range [0.] to [2pi].}} *)

  val of_lch_uv : lch_uv -> color
  (** [of_lch_uv c] is the L*C*h{_uv} color [c] as a [Gg] color. *)

  val to_lch_uv : color -> lch_uv
  (** [to_lch_uv c] is the [Gg] color [c] as a L*C*h{_uv}. *)

  (** {2:lab CIE L*a*b*} *)

  type lab = v4
  (** The type for colors in the CIE L*a*b* color space with a D50 reference
      white point and an alpha component. The meaning and range of the
      components is:
      {ul
      {- L* is lightness in the range [0.] to [100.]}
      {- a* and b*'s practical range is [-128.] to [127.]}} *)

  val of_lab : v4 -> color
  (** [of_lab c] is the L*a*b* color [c] as a [Gg] color value. *)

  val to_lab : color -> v4
  (** [to_lab c] is the [Gg] color [c] as a L*a*b* color. *)

  (** {2:lch_ab CIE L*C*h{_ab}} *)

  type lch_ab = v4
  (** The type for colors in the CIE L*C*h*{_ab} color space with a
      D50 reference white point and an alpha component. This color
      space is CIE L*a*b* with polar coordinates, the meaning and range
      of the components is:
     {ul
     {- L* is the lightness in the range [0.] to [100.]}
     {- C* represents chroma, in the range [0.] to
        [181.02], but less in practice.}
     {- h represents hue in degrees in the range [0.] to [2pi].}} *)

  val of_lch_ab : lch_ab -> color
  (** [of_lch_ab c] is the L*C*h{_ab} color [c] as a [Gg] color. *)

  val to_lch_ab : color -> lch_ab
  (** [to_lch_ab c] is the [Gg] color [c] as a L*C*h{_ab}. *)

  (** {1:colorspaces Color spaces} *)

  type space = [
    | `XYZ | `Lab | `Luv | `YCbr | `Yxy | `RGB | `Gray | `HSV | `HLS
    | `CMYK | `CMY | `CLR2 | `CLR3 | `CLR4 | `CLR5 | `CLR6 | `CLR7
    | `CLR8 | `CLR9 | `CLRA | `CLRB | `CLRC | `CLRD | `CLRE | `CLRF ]
  (** The type for color spaces. These correspond to the ICC v4 supported
      color space, see the
      {{:http://www.color.org/icc_specs2.xalter}specification},
      section 7.2.6. *)

  val space_dim : space -> int
  (** [space_dim s] is the dimension of the color space [s]. *)

  val pp_space : Format.formatter -> space -> unit
  (** [pp_space s] prints a textual representation of [s] on [ppf]. *)

  (** {1:colorprofiles Color profiles} *)

  type profile
  (** The type for {{:http://www.color.org/}ICC} color profiles. A
      color profile can describe the characteristics of a color space,
      an input or output device and provide a mapping to a profile
      connection space (PCS), which is either CIE L*a*b* or XYZ with a
      D50 white point.  For more information about ICC profile consult
      the {{:http://www.color.org/faqs.xalter}ICC FAQ} and the
      {{:http://color.org/icc_specs2.xalter}ICC v4 specification}.

      This module defines only a profile for the color space of
      {!color} and a grayscale color space. *)

  val profile_of_icc : string -> profile option
  (** [profile_of_icc s] is a profile from the ICC profile byte
      stream [s]. [None] is returned if [s] doesn't seem to be a ICC profile.

      {b Note} A profile value is returned if a color space can be
      extracted, it doesn't guarantee a correct ICC profile byte stream. *)

  val profile_to_icc : profile -> string
  (** [profile_to_icc p] is [p]'s ICC profile byte stream. *)

  val profile_space : profile -> space
  (** [profile_space p] is [p]'s color space. *)

  val profile_dim : profile -> int
  (** [profile_space p] is [space_dim (profile_space d)]. *)

  val p_gray_l : profile
  (** [p_gray_l] is a linear gray color profile *)

  val p_rgb_l : profile
  (** [p_rgb_l] is the color profile of {{!t}color} values. *)
end

(** {1:bigarray Linear bigarrays and bigarray buffers} *)

type ('a, 'b) bigarray = ('a, 'b, Bigarray.c_layout) Bigarray.Array1.t
(** The type for linear bigarrays. *)

type buffer =
  [ `Int8 of (int, Bigarray.int8_signed_elt) bigarray
  | `Int16 of (int, Bigarray.int16_signed_elt) bigarray
  | `Int32 of (int32, Bigarray.int32_elt) bigarray
  | `Int64 of (int64, Bigarray.int64_elt) bigarray
  | `UInt8 of (int, Bigarray.int8_unsigned_elt) bigarray
  | `UInt16 of (int, Bigarray.int16_unsigned_elt) bigarray
  | `UInt32 of (int32, Bigarray.int32_elt) bigarray
  | `UInt64 of (int64, Bigarray.int64_elt) bigarray
  | `Float16 of (int, Bigarray.int16_unsigned_elt) bigarray
  | `Float32 of (float, Bigarray.float32_elt) bigarray
  | `Float64 of (float, Bigarray.float64_elt) bigarray ]
(** The type for linear bigarray buffers. *)

(** Linear bigarrays and bigarray buffers.

    {b WARNING.} This interface is subject to change in the future.

    This module has a few convenience functions for linear (1D) bigarrays.

    The purpose of {!buffer} is to allow to specify a few more data
    types than bigarrays are able to express and facilitate the
    generic handling of linear bigarrays. *)
module Ba : sig

  (** {1:scalars Scalar types} *)

  (** The type for bigarray scalar types. *)
  type ('a, 'b) ba_scalar_type =
    | Int8 : (int, Bigarray.int8_signed_elt) ba_scalar_type
    | Int16 : (int, Bigarray.int16_signed_elt) ba_scalar_type
    | Int32 : (int32, Bigarray.int32_elt) ba_scalar_type
    | Int64 : (int64, Bigarray.int64_elt) ba_scalar_type
    | UInt8 : (int, Bigarray.int8_unsigned_elt) ba_scalar_type
    | UInt16 : (int, Bigarray.int16_unsigned_elt) ba_scalar_type
    | UInt32 : (int32, Bigarray.int32_elt) ba_scalar_type
    | UInt64 : (int64, Bigarray.int64_elt) ba_scalar_type
    | Float16 : (int, Bigarray.int16_unsigned_elt) ba_scalar_type
    | Float32 : (float, Bigarray.float32_elt) ba_scalar_type
    | Float64 : (float, Bigarray.float64_elt) ba_scalar_type

  val ba_kind_of_ba_scalar_type :
    ('a, 'b) ba_scalar_type -> ('a, 'b) Bigarray.kind
  (** [ba_kind_of_ba_scalar_type st] is the bigarray kind corresponding
      to [st]. *)

  type scalar_type =
    [ `Int8 | `Int16 | `Int32 | `Int64
    | `UInt8 | `UInt16 | `UInt32 | `UInt64
    | `Float16 | `Float32 | `Float64 ]
  (** The type for buffer scalar types. *)

  val scalar_type_of_ba_scalar_type : ('a, 'b) ba_scalar_type -> scalar_type
  (** [scalar_type_of_ba_scalar_type st] is the scalar type corresponding
      to [st]. *)

  val scalar_type_byte_count : scalar_type -> int
  (** [scalar_type_byte_count st] is the number of bytes used by a scalar
      of type [st]. *)

  val pp_scalar_type : Format.formatter -> scalar_type -> unit
  (** [pp_scalar_type ppf st] prints a textual representation of [st]
      on [ppf]. *)

  (** {1:buffers Bigarray buffers} *)

  module Buffer : sig

    type t = buffer
    (** The type for bigarray buffers. *)

    val create : scalar_type -> int -> buffer
    (** [create st count] is a buffer of scalar type [st] with
        [count] scalars. *)

    val scalar_type : buffer -> scalar_type
    (** [buffer_scalar_type b] is [b]'s buffer scalar type. *)

    val length : buffer -> int
    (** [buffer_length b] is [b]'s buffer scalar length. *)

    val byte_length : buffer -> int
    (** [buffer_byte_length b] is [b]'s buffer byte length. *)

    val of_bigarray : ?data:[`Unsigned | `Float] -> ('a, 'b) bigarray -> buffer
    (** [of_bigarray ba] is a buffer for the bigarray [ba]. [data]
        can be used to add information whenever the bigarray kind is:
        {ul
        {- {!Bigarray.int16_unsigned}, if [`Float] is specified
           the scalar type will be [`Float16].}
        {- {!Bigarray.int32} or {!Bigarray.int64}, if [`Unsigned] is
           specified the scalar type will be, respectively [`UInt32]
           and [`UInt64].} }
        Raises [Invalid_argument] if the bigarray kind does not
        correspond to a {!Ba.scalar_type} or if [data] is irrelevant. *)

    val pp : Format.formatter -> buffer -> unit
    (** [pp b] prints a textual representation of [b] on
        [ppf]. Does not print the buffer's data. *)
  end

  (** {1:ba Bigarrays} *)

  val create : ('a, 'b) ba_scalar_type -> int -> ('a, 'b) bigarray
  (** [create k count] is a bigarray of kind [k] with [count] scalars. *)

  val length : ('a, 'b) bigarray -> int
  (** [length ba] is the length of [ba]. *)

  val sub : ('a, 'b) bigarray -> int -> int -> ('a, 'b) bigarray
  (** [sub ba i len] are the [i]th to [i]th + [n] scalars of [ba]
      as a bigarray. Note, this is not a copy. *)

  val blit : ('a, 'b) bigarray -> int -> ('a, 'b) bigarray -> int -> int -> unit
  (** [blit src si dst di len] copies [len] scalar values starting at [si]
      in [src] to [dst] starting at [di]. *)

  val fill : ('a, 'b) bigarray -> 'a -> unit
  (** [fill ba v] sets each scalar value of [ba] to [v]. *)

  val of_array : ('a, 'b) ba_scalar_type -> 'a array -> ('a, 'b) bigarray
  (** [of_array st a] is a bigarray from array [a]. *)

  val of_list : ('a, 'b) ba_scalar_type -> 'a list -> ('a, 'b) bigarray
  (** [of_list st l] is a bigarray from list [l]. *)

  val of_bytes : ?be:bool -> ('a, 'b) ba_scalar_type -> string ->
    ('a, 'b) bigarray
  (** [of_bytes be s k] is a bigarray of kind [k] from [s]. if [be]
      is [true] data is assumed to be in big endian order (defaults to
      [false]).

      {b TODO} For now only [Int8] and [UInt8] are supported.

      Raises [Invalid_argument] if given an unsupported kind or if
      the data length is not a multiple of the requested scalar type. *)

  val pp : ?count:int -> ?stride:int -> ?first:int -> ?dim:int ->
    pp_scalar:(Format.formatter -> 'a -> unit) ->
    Format.formatter -> ('a, 'b) bigarray -> unit
  (** [pp count stride first dim pp_scalar ppf b] prints on [ppf],
      [count] groups of size [dim] of scalars of [b], starting at [first]
      using [pp_scalar], and striding [stride] scalars to go from group
      to group. If [count] is unspecified prints as much as
      possible. [stride] defaults to [dim], [first] defaults to [0] and
      [dim] to [1]. *)


  (** {1:get Getting} *)

  (**/**)
  val unsafe_get : ('a, 'b) bigarray -> int -> 'a
  (**/**)

  val get_v2 : (float, 'b) bigarray -> int -> v2
  (** [get_v2 b i] is the [i]th to [i+1]th scalars of [b] as a vector. *)

  val get_v3 : (float, 'b) bigarray -> int -> v3
  (** [get_v3 b i] is the [i]th to [i+2]th scalars of [b] as a vector. *)

  val get_v4 : (float, 'b) bigarray -> int -> v4
  (** [get_v4 b i] is the [i]th to [i+3]th scalars of [b] as a vector. *)

  val get_2d : ('a, 'b) bigarray -> int -> ('a * 'a)
  (** [get_v2 b i] is the [i]th to [i+1]th scalars of [b]. *)

  val get_3d : ('a, 'b) bigarray -> int -> ('a * 'a * 'a)
  (** [get_v3 b i] is the [i]th to [i+2]th scalars of [b]. *)

  val get_4d : ('a, 'b) bigarray -> int -> ('a * 'a * 'a * 'a)
  (** [get_v4 b i] is the [i]th to [i+3]th scalars of [b]. *)

  (** {2:get_int32 int32 Bigarray} *)

  val geti_2d : (int32, 'b) bigarray -> int -> (int * int)
  (** [get_v2 b i] is the [i]th to [i+1]th scalars of [b]. The
      integers are converted with {!Int32.to_int}. *)

  val geti_3d : (int32, 'b) bigarray -> int -> (int * int * int)
  (** [get_v3 b i] is the [i]th to [i+2]th scalars of [b]. The
      integers are converted with {!Int32.to_int} *)

  (** {1:set Setting} *)

  (**/**)
  val unsafe_set : ('a, 'b) bigarray -> int -> 'a -> unit
  (**/**)

  val set_v2 : (float, 'b) bigarray -> int -> v2 -> unit
  (** [set_v2 b i v] sets the [i]th to [i+1]th scalars of [b] with
      [v]. *)

  val set_v3 : (float, 'b) bigarray -> int -> v3 -> unit
  (** [set_v3 b i v] sets the [i]th to [i+2]th scalars of [b] with
      [v]. *)

  val set_v4 : (float, 'b) bigarray -> int -> v4 -> unit
  (** [set_v4 b i v] sets the [i]th to [i+3]th scalars of [b] with
      [v]. *)

  val set_2d : ('a, 'b) bigarray -> int -> 'a -> 'a -> unit
  (** [set_2d b i s1 s2] sets the [i]th to [i+1]th scalar of [b] to
      [s1], [s2]. *)

  val set_3d : ('a, 'b) bigarray -> int -> 'a -> 'a -> 'a -> unit
  (** [set_3d b i s1 s2 s3] sets the [i]th to [i+2]th scalar of [b] to
      [s1], [s2], [s3]. *)

  val set_4d : ('a, 'b) bigarray -> int -> 'a -> 'a -> 'a -> 'a -> unit
  (** [set_4d b i s1 s2 s3 s4] sets the [i]th to [i+3]th scalar of [b]
      to [s1], [s2], [s3], [s4]. *)

  (** {2:set_int32 int32 Bigarray} *)

  val seti_2d : (int32, 'b) bigarray -> int -> int -> int -> unit
  (** [set_2d b i s1 s2] sets the [i]th to [i+1]th scalar of [b] to
      [s1], [s2]. *)

  val seti_3d : (int32, 'b) bigarray -> int -> int -> int -> int -> unit
  (** [set_3d b i s1 s2 s3] sets the [i]th to [i+2]th scalar of [b] to
      [s1], [s2], [s3]. *)
end

(** {1:raster Raster data} *)

type raster
(** The type for raster data. *)

(** Raster data.

    {b WARNING.} This interface is subject to change in the future.

    Raster data organizes data samples of any dimension in discrete
    1D, 2D (images) or 3D space.

    A sample has a {{!Raster.Sample.type-semantics}{e semantics}} that
    defines its dimension and the meaning of its {e components}. For
    example a 4D sample could represent a linear sRGBA sample. Samples
    are stored in a {{!buffer}linear buffer} of {e scalars} of a given
    {{!type:Ba.scalar_type}type}. A sample can use one scalar per
    component, can be packed in a single scalar or may have no direct
    obvious relationship to buffer scalars (compressed data). The
    {{!Raster.Sample.type-format}sample format} defines the semantics
    and scalar storage of a sample.

    A {{!Raster.t}{e raster data}} value is a collection of samples indexed
    by width, height and depth (i.e. x, y, z) stored in a buffer.  It
    defines the sample data, the extents of the index and the sample
    format.  The optional {{!Raster.res}resolution} in samples per meters of
    a raster data can specify its physical dimension.

    {b Spatial convention.} If the sample index has to be interpreted
    spatially. It must be interpreted relative to the origin of a
    right-handed coordinate system. This means that the first sample,
    indexed by [(0,0,0)] is the bottom-left backmost sample
    (bottom-left sample for a 2D image).

    {b Index sizes.} Index sizes are specified using
    {{!sizes}size} types which are made of floats as it is more
    pratical in most scenarios. These floats should however be {e
    integral} floats. The function {!Raster.v}, {!Raster.Sample.scalar_count}
    and {!Raster.sub} ensure this by applying {!Float.val-round} to these
    values.
    This means that the {{!Raster.section-rsize}raster size functions} when
    called with [meters = false] will always return sizes that are integral
    floats that you can convert to integers safely without having to think about
    rounding issues. Note also that index sizes are always strictly
    positive.*)
module Raster : sig

  (** {1:samples Sample semantics and formats} *)

  (** Sample semantics and formats. *)
  module Sample : sig

    (** {1:semantics Sample semantics} *)

    type semantics =
      [ `Other of string * int
      | `Color of Color.profile * bool]
    (** The type for sample semantics.
        {ul
        {- [`Color (p, alpha)] is for color samples from the
           color profile [p]. [alpha] indicates if there's an alpha
           component on the {e right} of the color components.}
        {- [`Other(label, dim)] is for samples of [dim] dimension
           identified by [label].}} *)

    val rgb_l : semantics
    (** [rgb_l] is for linear RGB samples from the {!Color.p_rgb_l}
        profile. *)

    val rgba_l : semantics
    (** [rgba_l] is for linear RGB samples from the  {!Color.p_rgb_l}
        profile with an alpha component. *)

    val gray_l : semantics
    (** [gray_l] is for linear Gray samples from the {!Color.p_gray_l}
        profile. *)

    val graya_l : semantics
    (** [graya_l] is for linear Gray samples from the {!Color.p_gray_l}
        luminance with an alpha component. *)

    val pp_semantics : Format.formatter -> semantics -> unit
    (** [pp_sample_semantics ppf sem] prints a textual representation of [sem]
        on [ppf]. *)

    (** {1:samples Sample format} *)

    type pack =
      [ `PU8888 | `FourCC of string * Ba.scalar_type option
      | `Other of string * Ba.scalar_type option ]
    (** The type for sample packs. A sample pack describes storage for samples
        that do not use one scalar per component.
        {ul
        {- [`PU8888]. An arbitrary 4D sample X, Y, Z, W with unsigned
         8 bits components packed in a single [`UInt32] scalar
         as [0xXXYYZZWWl].}
        {- [`FourCC(code, restrict)]. A sample is stored according to the
           format specified by the FourCC [code], a string of length 4.
           If [restrict] is specified the pack can only be used with the
           corresponding scalar type. For example [`FourCC("DXT5", Some
           `UInt64)] can be used to specify a buffer of DXT5 compressed
           data. [`FourCC] can also be used to describe the numerous YUV
           packed pixel formats.}
        {- [`Other(label, restrict)]. A sample is stored in some other
           packing scheme identified by [label], [restrict] has the same
           meaning as in [`FourCC].}} *)

    val pp_pack : Format.formatter -> pack -> unit
    (** [pp_pack ppf pack] prints a textual representation of [pack]
        on [ppf]. *)

    type format
    (** The type for sample formats. *)

    val format : ?pack:pack -> semantics -> Ba.scalar_type -> format
    (** [format pack sem st] is a sample format with semantics
        [sem] and scalar type [st]. If [pack] is absent one scalar of type [st]
        per sample component is used. If present, see {!type:Sample.pack}.

        Raises [Invalid_argument] if [pack] is incompatible with [st],
        see {!type:Sample.pack} or if a [pack] [`FourCC] code is not made of
        4 bytes. *)

    val semantics : format -> semantics
    (** [semantics sf] is [sf]'s semantics. *)

    val scalar_type : format -> Ba.scalar_type
    (** [scalar_type sf] is [sf]'s buffer scalar type *)

    val pack : format -> pack option
    (** [pack sf] is [sf]'s sample pack, if any. *)

    val dim : format -> int
    (** [dim sf] is [sf]'s sample dimension. *)

    val scalar_count : ?first:int -> ?w_stride:int -> ?h_stride:int ->
      [ `D1 of size1 | `D2 of size2 | `D3 of size3 ] -> format -> int
    (** [sf_scalar_count first w_stride h_stride size sf] is the minimal
        number of scalars needed to hold a raster data with the
        corresponding parameters, see {!v} for their description.

        Raises [Invalid_argument] if [sf] is packed. *)

    val pp_format : Format.formatter -> format -> unit
    (** [pp_format ppf sf] prints a textual representation of [sf]
        on [ppf].*)
  end

  (** {1:raster Raster data} *)

  type t = raster
  (** The type for raster data. *)

  val v : ?res:v3 -> ?first:int -> ?w_stride:int -> ?h_stride:int ->
    [ `D1 of float | `D2 of size2 | `D3 of size3 ] -> Sample.format ->
    buffer -> t
  (** [v res first w_stride h_stride size sf buf] is raster data with
      sample format [sf] and buffer [b].
      {ul
      {- [size], specify the index extents. height and depth if unspecified
         default to [1]. All extents must be strictly positive.}
      {- [first], {e buffer scalar} index where the data of the first sample
         is stored.}
      {- [w_stride], number of {e samples} ({b not} buffer scalars) to skip
         to go from the first sample of a line to the first sample of the next
         line. Defaults to the index width.}
      {- [h_stride], number of {e lines} to skip to go from the first line
         of a plane to the first line of the next plane. Defaults to the
         index height.}
      {- [res], is an optional sample resolution specification in
         samples per meters.}}

      For certain sample formats [first], [w_stride] and [h_stride] can be
      used to specify subspaces in the collection of samples, see {!sub}.

      The function {!scalar_strides} can be used to easily compute the
      linear buffer scalar index where a sample [(x,y,z)] starts.

      Raises [Invalid_argument] if the elements of [size] are not stricly
      positive, if [first] is negative, if [w_stride] or [h_stride] are
      smaller than the index width or height or if the scalar type of
      [sf] doesn't match [(Raster.buffer_scalar_type b)]. *)

  val res : t -> v3 option
  (** [res r] is [r]'s resolution in sample per meters, if any. *)

  val get_res : t -> v3
  (** [get_res r] is {!res} but raises [Invalid_argument]
      if there's no resolution. *)

  val first : t -> int
  (** [first r] is the {e buffer scalar} index where the first sample
      is stored. *)

  val w_stride : t -> int
  (** [w_stride r] is the number of {e samples} to skip to go
      from the first sample of a line to the first sample of
      the next line. *)

  val h_stride : t -> int
  (** [h_stride r] is the number of {e lines} to skip to go
      from the first line of a plane to the first
      line of the next plane. *)

  val sample_format : t -> Sample.format
  (** [sample_format r] is [r]'s sample format. *)

  val buffer : t -> buffer
  (** [buffer r] is [r]'s format. *)

  (** {1:rsize Raster sizes and boxes}

      In these functions have an optional [meter] argument that
      defaults to [false]. If [false] the result is in integral number
      of {e samples}. If [true] the result is in {e meters} according
      to the rasters' {{!res}resolution}.  If the raster has no
      resolution, {!Raster.res_default} is used in all dimensions. *)

  val wi : t -> int
  (** [wi r] is [r]'s index width in number of samples. *)

  val hi : t -> int
  (** [hi r] is [r]'s index height in number of samples. *)

  val di : t -> int
  (** [d r] is [r]'s index height in number of samples. *)

  val w : ?meters:bool -> t -> float
  (** [w r] is [r]'s index width. *)

  val h : ?meters:bool -> t -> float
  (** [h r] is [r]'s index height. *)

  val d : ?meters:bool -> t -> float
  (** [d r] is [r]'s index depth. *)

  val size1 : ?meters:bool -> t -> size1
  (** [size1 r] is [r]'s index width. *)

  val size2 : ?meters:bool -> t -> size2
  (** [size2 r] is [r]'s index width and height. *)

  val size3 : ?meters:bool -> t -> size3
  (** [size3 r] is [r]'s index width, height and depth. *)

  val box1 : ?meters:bool -> ?mid:bool -> ?o:float -> t -> box1
  (** [box1 meters mid o r] is a box with origin [o] and size [(size1
      meters r)]. If [mid] is [true] (defaults to [false]), [o]
      specifies the mid point of the box. [o] defaults to 0. *)

  val box2 : ?meters:bool -> ?mid:bool -> ?o:p2 -> t -> box2
  (** [box2 meters mid o r] is a box with origin [o] and size [(size2
      meters r)]. If [mid] is [true] (defaults to [false]), [o]
      specifies the mid point of the box. [o] defaults to {!P2.o}. *)

  val box3 : ?meters:bool -> ?mid:bool -> ?o:p3 -> t -> box3
  (** [box3 meters mid o r] is a box with origin [o] and size
      [(size3 meters r)]. If [mid] is [true] (defaults to [false]),
      [o] specifies the mid point of the box. [o] defaults to {!P3.o}. *)

  (** {1:functions Functions} *)

  val dim : t -> int
  (** [dim r] is [r]'s index dimension from 1 to 3. Note that
      this is not derived from the case size given to {!v} for creating [r].
      It is derived from the size [(w,h,d)] as follows: [(w,1,1)] means 1,
      [(w,h,1)] with [h > 1] means 2, [(w,h,d)] with [h,d > 1] means 3. *)

  val kind : t -> [ `D1 | `D2 | `D3 ]
  (** [kind r] is like {!dim} but symbolically. *)

  val sub : [ `D1 of box1 | `D2 of box2 | `D3 of box3 ] -> t -> t
  (** [sub region] is a raster corresponding to a subset of the
      index of [r]. Both [r] and the resulting raster share
      the same buffer. The integral origin of the box defines the
      new sample origin of the raster data and its integral
      size the new size of the index.

      If the dimension of the box is smaller than the raster the
      result is in the first line ([y = 0]) and/or layer ([z = 0]) of
      the raster [r].

      Raises [Invalid_argument], if the sample format of [r] is packed,
      if the origin is out of bounds or if new size is larger than
      [r]'s size. *)

  val scalar_strides : t -> int * int * int
  (** [scalar_strides r] is [(x_stride, y_stride, z_stride)] where
      {ul
       {- [x_stride] is the number of buffer scalars from sample to sample.}
       {- [y_stride] is the number of buffer scalars from line to line.}
       {- [z_stride] is the number of buffer scalars from plane to plane.}}
      The buffer index where the sample [(x,y,z)] starts is given by:
{[
(Raster.first r) + z * z_stride + y * y_stride + x * x_stride
]}
      Raises [Invalid_argument] if the sample format of [r] is
      packed.
  *)

  (** {1:preds Predicates and comparisons} *)

  val equal : t -> t -> bool
  (** [equal r r'] is [r = r']. *)

  val compare : t -> t -> int
  (** [compare r r'] is [Stdlib.compare r r']. *)

  (** {1:fmt Formatters} *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf t] prints a textual represenation of [t] on [ppf]. Doesn't
      print the buffer samples. *)

  (** {1:resolution Default resolution and conversions} *)

  val res_default : float
  (** [res_default] is 11811spm (300spi). *)

  val spm_of_spi : float -> float
  (** [spm_of_spi spi] is the samples per meter corresponding to
        the samples per inch [spi]. *)

  val spm_to_spi : float -> float
  (** [spm_to_spi spm] is the samples per inch corresponding to the
      samples per meters [spm]. *)
end

(** {1:basics Basics}

    [Gg] is designed to be opened in your module. This defines only
    types and modules in your scope, no values. Thus to use [Gg] start
    with :
{[
open Gg
]}
    In the toplevel enter:
{[
> #require "gg.top";;
]}
    to automatically open [Gg] and install printers for the types.

    {2:conventions Conventions}

    Most types and their functions are defined with the following
    conventions. The type is first defined in [Gg], like {!v2} for 2D
    vectors, a module for it follows. The name of the module is
    the type name capitalized, e.g. {!V2} for 2D vectors and it has
    the following definitions:
    {ul
    {- a type [t] equal to the original toplevel type ({!V2.t}).}
    {- [dim], an [int] value that indicates the dimensionality
       of the type ({!V2.dim}).}
    {- [v], a constructor for the type ({!V2.v}).}
    {- [pp] to convert values to a textual representation for debugging
       purposes and toplevel interaction {!V2.pp}).}
    {- [equal] and [compare] the standard functions that make a module
       a good functor argument ({!V2.equal}, {!V2.compare}).}
    {- [equal_f] and [compare_f] which compare
       like [equal] and [compare] but allow to use a client provided
       function to compare floats ({!V2.equal_f}, {!V2.compare_f}).}
    {- [ltr] and [tr] to apply linear and affine transforms
       on the type ({!V2.ltr}, {!V2.tr}).}
    {- Other accessors (e.g. {!V2.x}), constants (e.g. {!V2.zero}),
       functions (e.g. {!V2.dot}) and predicates (e.g. {!V2.exists})
       specific to the type.}
    {- Modules that represent the same object but for different
       dimensions, like {!V2}, {!V3}, {!V4} for vectors,  usually
       share a common signature. This common
       signature is collected in a module type defined in [Gg],
       this signature is {!V} for vectors.}}

    Some types are defined as simple abreviations. For example the
    type {!p2} for 2D points is equal to {!v2}. These types also have
    a module whose name is the type name capitalized, {!P2} in our
    example. However this module only provides alternate constructors,
    constants and accessors and the extended functionality specific to the
    type. You should fallback on the module of the abreviated type
    ({!V2} in our example) for other operations. The aim of these
    types is to make your code and signatures semantically clearer
    without the burden of explicit conversions.

    Finally there are some types and modules like {!Color} whose structure
    is different because they provide specific functionality.

    Here are a few other conventions :
    {ul
    {- Numbers in names indicate dimensionality. For example {!M4.scale3}
       indicates scale in 3D space while {!M4.scale4} scale in 4D space.}
    {- Most functions take the value they act upon first.
       But exceptions abound, to match OCaml conventions, to have your
       curry or to match mathematical notation (e.g. {!V2.tr}).}
    {- Conversion functions follow the [of_] conventions. Thus to convert
       a value of type [t'] to a value of type [t] look for the function
       named [T.of_t'].}}

    To conclude note that it is sometimes hard to find the right place
    for a function. If you cannot find a function look into each of
    the modules of the types you want to act upon.

    {2:mathconv Mathematical conventions}
    {ul
    {- In 3D space we assume a
    {{:http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html}
    right-handed} coordinate system.}
    {- Angles are always given in radians (except in
      {{!Float.rad_of_deg}this} function...).}
    {- In 2D space positive angles determine counter clockwise rotations.}
    {- In 3D space positive angles determine rotations directed according to
       the right hand rule.}}

    {2:colornote Note on colors}

    Values of type {!color} are in a {e linear} sRGB space as this is
    the space to work in if you want to process colors correctly (e.g.
    for blending). The constructor {!Color.v_srgb} takes its parameters
    from a {e non-linear} sRGB space and converts them to {e linear}
    sRGB.
{[
# let c = Color.v_srgb 0.5 0.5 0.5 1.0;;
- : Gg.color = (0.214041 0.214041 0.214041 1)
]}
    This is the constructor you are likely to use when you specify color
    constants (e.g. to specify a color value matching a CSS color).
    If you need an sRGB color back from a {!color} value use {!Color.to_srgb}:
{[
# Color.to_srgba c;;
- : Gg.Color.srgba = (0.5 0.5 0.5 1)
]}

    {2:tipsremarks Remarks and Tips}
    {ul
    {- Everything is tail-recursive.}
    {- Do not rely on the output of printer functions, they are
       subject to change. The only exception is the function
       {!Float.pp} that output a lossless textual representation of
       floats.  While the actual format is subject to change it will
       remain compatible with [float_of_string].}
    {- All modules can be directly given as arguments to [Set.Make]
       and [Map.Make]. However this will use [Stdlib.compare] and
       thus binary comparison between floats. Depending on the intended
       use this may be sensible or not. Comparisons with alternate functions
       to compare floats can be defined by using the functions named
       [compare_f] (e.g. {!V2.compare_f}).  An alternate float comparison
       function is {!Float.compare_tol}
       that combines relative and absolute float comparison in a single
       test, see {!Float.equal_tol} for the details.}
    {- For performance reasons some functions of the {!Float} module
       are undefined on certain arguments but do not raise [Invalid_argument]
       on those. As usual do not rely on the behaviour of functions on undefined
       arguments, these are subject to change.}}
*)

(*---------------------------------------------------------------------------
   Copyright (c) 2013 The gg programmers

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ---------------------------------------------------------------------------*)
