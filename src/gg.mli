(*---------------------------------------------------------------------------
   Copyright (c) 2013 Daniel C. BÃ¼nzli. All rights reserved.
   Distributed under a BSD license, see license at the end of the file.
   %%PROJECTNAME%% release %%VERSION%%
  --------------------------------------------------------------------------*)

(** Basic types for computer graphics.  

    [Gg] defines types and functions for {{!Float}floats},
    {{!vectors}vectors}, {{!points}points}, {{!matrices}matrices}, 
    {{!quaternions}quaternions}, {{!sizes}sizes}, 
    {{!aboxes}axis aligned boxes}, {{!colors}colors}, 
    {{!Color.colorprofiles}color profiles} and {{!raster}raster data}.

    Consult the {{!basics}basics}. Open the module to use it, this
    defines only modules and types in your scope. 

    {e Release %%VERSION%% - %%MAINTAINER%% } *)

(**    {1:float Floats} *)

(** Floating point number utilities.  

    This module defines a few useful {{!constants}constants},
    {{!functions}functions}, {{!comparisons}predicates and
    comparisons} on floating point numbers. The {{!printers}printers}
    output a lossless textual representation of floats.

    {{!floatrecall}Quick recall} on OCaml's floating
    point representation. *)
module Float : sig

  type t = float
  (** The type for floating point numbers. *)

  (** {1:constants Constants} *)

  val e : float 
  (** The constant {{:http://mathworld.wolfram.com/e.html}e}. *)
 
  val pi : float
  (** The constant {{:http://mathworld.wolfram.com/Pi.html}pi}. *)

  val two_pi : float
  (** [2 *. pi] *)

  val pi_div_2 : float
  (** [pi /. 2]. *)

  val pi_div_4 : float
  (** [pi /. 4]. *)

  val inv_pi : float
  (** [1 /. pi]. *)

  val max_sub_float : float
  (** The greatest positive subnormal floating point number. *)

  val min_sub_float : float 
  (** The smallest positive subnormal floating point number. *)

  val max_frac_float : float 
  (** The greatest positive floating point number with a fractional
      part (the [float] before 2{^52}). Any number outside
      \[[-max_frac_float;max_frac_float]\] is an integer. *)

  val max_int_arith : float 
  (** The greatest positive floating point number (2{^53}) such that
      any {e integer} in the range
      \[[-max_int_arith;max_int_arith]\] is represented exactly.
      Integer arithmetic can be performed exactly in this interval. *)

  (** {1:functions Functions} 
      
      {b Note.} If applicable, a function taking NaNs returns a NaN 
      unless otherwise specified. *)

  val deg_of_rad : float -> float
  (** [deg_of_rad r] is [r] 
     {{:http://mathworld.wolfram.com/Radian.html}radians} in 
     {{:http://mathworld.wolfram.com/Degree.html}degrees}. *)

  val rad_of_deg : float -> float
  (** [rad_of_deg d] is [d]
     {{:http://mathworld.wolfram.com/Degree.html}degrees} in
     {{:http://mathworld.wolfram.com/Radian.html}radians}. *) 

  val wrap_angle : float -> float
  (** [wrap_angle r] is the angle [r] in the interval \[[-pi;pi]\[. *)

  val random : ?min:float -> len:float -> unit -> float
  (** [random min len ()] is a random float in the interval
      \[[min;min+len]\] ([min] defaults to 0.). Uses the standard
      library's default [Random] state for the generation.

     {b Warning.} The float generated by a given state may
     change in future versions of the library. *)

  val srandom : Random.State.t -> ?min:float -> len:float -> unit -> float 
  (** [srandom state min len ()] is like {!random} but uses [state]
      for the generation. 
      
      {b Warning.} The float generated by a given [state] may
      change in future versions of the library. *)

  val mix : float -> float -> float -> float
  (** [mix x y t] is the linear interpolation [x +. t *. (y -. x)]. *)

  val step : float -> float -> float 
  (** [step edge x] is [0.] if [x < edge] and [1.] otherwise. The
      result is undefined on NaNs. *)

  val smooth_step : float -> float -> float -> float 
  (** [smooth_step e0 e1 x] is [0.] if [x <= e0], [1.] if [x >= e1]
      and cubic hermite interpolation between 0. and 1. otherwise. The
      result is undefined on NaNs. *)

  val fmax : float -> float -> float 
  (** [fmax x y] is [y] if [x < y] and [x] otherwise. If [x] or [y] is
      NaN returns the other argument. If both are NaNs returns NaN. *)

  val fmin : float -> float -> float 
  (** [fmin x y] is [x] if [x < y] and [y] otherwise. If [x] or [y] is
      NaN returns the other argument. If both are NaNs returns NaN. *)

  val clamp : min:float -> max:float -> float -> float 
  (** [clamp min max x] is [min] if [x < min], [max] if [x > max] and
      [x] otherwise. The result is undefined on NaNs and if [min >
      max]. *)

  val remap : x0:float -> x1:float -> y0:float -> y1:float -> float -> 
    float
  (** [remap x0 x1 y0 y1 v] applies to [v] the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transform} that maps [x0] to [y0] and [x1] to [y1]. If the
      transform is undefined ([x0 = x1] and [y0 <> y1]) the function
      returns [y0] for any [v]. *)

  val round : float -> float
  (** [round x] is the integer nearest to [x]. Ties are rounded
      towards positive infinity. If [x] is an infinity, returns [x]. 

      {b Note.} If the absolute magnitude of [x] is an integer strictly 
      greater than {!max_frac_float}, [round x = x] may be [false].  *)

  val int_of_round : float -> int
  (** [int_of_round x] is [truncate (round v)]. The result is 
      undefined on NaNs and infinities. *)

  val round_dfrac : int -> float -> float 
  (** [round_dfrac d x] rounds [x] to the [d]th {e decimal} fractional
      digit. Ties are rounded towards positive infinity.  If [x] is an
      infinity, returns [x]. The result is only defined for [0 <= d <=
      16]. *)

  val round_dsig : int -> float -> float 
  (** [round_dsig d x] rounds the normalized {e decimal} significand
      of [x] to the [d]th decimal fractional digit. Ties are rounded
      towards positive infinity. The result is NaN on infinities.  The
      result only defined for [0 <= d <= 16].

      {b Warning.} The current implementation overflows on large [x]
      and [d]. *)

  val round_zero : eps:float -> float -> float 
  (** [round_zero eps x] is [0.] if [abs_float x < eps] and [x] otherwise. 
      The result is undefined if [eps] is NaN. *)

  val chop : eps:float -> float -> float
  (**  [chop eps x] is [round x] if [abs_float (x -. round x) < eps] and [x] 
       otherwise. The result is undefined if [eps] is NaN. *)

  val sign : float -> float 
  (** [sign x] is [1.] if [x > 0.], [0.] if [x = 0.], [-1.] if [x < 0.] *)

  val sign_bit : float -> bool
  (** [sign_bit x] is [true] iff the sign bit is set in [x]. *)
  
  val succ : float -> float 
  (** [succ x] is the floating point value just after [x] towards positive
      infinity. Returns in particular : 
      {ul 
      {- NaN on NaNs.}
      {- [infinity] on [infinity].}
      {- [-max_float] on [neg_infinity].}
      {- [min_sub_float] on [0.] {b or} [-0.].}} *)

  val pred : float -> float 
  (** [pred x] is [-. succ (-.x)], i.e. the floating point value before 
      [x] towards negative infinity. *)

  val nan : int -> float 
  (** [nan payload] is a NaN whose 51 lower significand bits are
      defined by the 51 lower (or less, as [int] allows) bits of
      [payload]. *)

  val nan_payload : float -> int
  (** [nan_payload x] is the 51 lower significand bits (or less, as
      [int] allows) of the NaN [x].  

      @raise Invalid_argument if [x] is not a NaN. *)

  (** {1:comparisons Predicates and comparisons} *)

  val is_zero : eps:float -> float -> bool
  (** [is_zero eps x] is [true] if [abs_float x < eps] 
      and [false] otherwise. The result is undefined if [eps] is NaN. *)

  val is_nan : float -> bool 
  (** [is_nan x] is [true] iff [x] is a NaN. *)

  val is_inf : float -> bool 
  (** [is_inf x] is [true] iff [x] is [infinity] or [neg_infinity]. *)

  val is_int : float -> bool
  (** [is_int x] is [true] iff [x] is an integer. *)

  val equal : float -> float -> bool
  (** [equal x y] is [x = y]. *)

  val equal_tol : eps:float -> float -> float -> bool 
  (** [equal_tol eps x y] is [true] iff |[x - y]| <= [eps] * max
      (1,|[x]|,|[y]|). On special values the function behaves like
      [compare x y = 0].  The condition turns into an absolute tolerance 
      test for small magnitudes and a relative tolerance test for 
      large magnitudes. *)

  val compare : float -> float -> int
  (** [compare x y] is [Pervasives.compare x y]. *)

  val compare_tol : eps:float -> float -> float -> int
  (** [compare_tol ~eps x y] is [0] iff [equal_tol ~eps x y] is [true]
      and [Pervasives.compare x y] otherwise. *)

  (** {1:printers Printers} *)
  
  val to_string : float -> string
  (** [to_string x] is a lossless textual representation of [x].
      {ul 
      {- Normals are represented by ["[-]0x1.<f>p<e>"] where
         [<f>] is the significand bits in hexadecimal and [<e>] the 
         unbiased exponent in decimal.}
      {- Subnormals are represented by ["[-]0x0.<f>p-1022"] where 
         [<f>] is the significand bits in hexadecimal.}
      {- NaNs are represented by ["[-]nan(0x<p>)"] where [<p>] is the payload
         in hexadecimal.}
      {- Infinities and zeroes are represented by ["[-]inf"] and ["[-]0."].}}

      This format should be compatible with recent implementations of 
      {{:http://www.opengroup.org/onlinepubs/000095399/functions/strtod.html}
      strtod} and hence with [float_of_string] (but negative NaNs seem to 
      be problematic to get back) . *)

  val pp : Format.formatter -> float -> unit
  (** [pp ppf x] prints [x] on [ppf] according to the lossless
      representation of {!to_string}. *) 

  (** {1:floatrecall Quick recall on OCaml's [float]s} 

     An OCaml [float] is an
     {{:http://ieeexplore.ieee.org/servlet/opac?punumber=4610933}IEEE-754}
     64 bit double precision binary floating point number. The 64 bits
     are laid out as follows :
{v
+----------------+-----------------------+-------------------------+
| sign s (1 bit) | exponent e (11 bits)  | significand t (52 bits) |
+----------------+-----------------------+-------------------------+
               63|62                   52|51                      0|
v}
   
    The value represented depends on s, e and t :
{v
sign   exponent       significand   value represented           meaning
-------------------------------------------------------------------------
s      0              0             -1^s * 0                    zero
s      0              t <> 0        -1^s * 0.t * 2^-1022        subnormal
s      0 < e < 2047   f             -1^s * 1.t * 2^(e - 1023)   normal
s      2047           0             -1^s * infinity             infinity
s      2047           t <> 0        NaN                         not a number
v}

     There are two zeros, a positive and a negative one but both are
     deemed equal by [=] and [Pervasives.compare]. A NaN is never equal
     (=) to {e itself} or to another NaN however [Pervasives.compare]
     asserts any NaN to be equal to itself and to any other NaN.

     The bit layout of a [float] can be converted to an [int64] and
     back using [Int64.bits_of_float] and [Int64.float_of_bits].
     
     The bit 51 of a NaN is used to distinguish between quiet (bit set)
     and signaling NaNs (bit cleared); the remaining 51 lower bits of
     the significand are the NaN's {e payload} which can be used to
     store diagnostic information. These features don't seem to used in
     OCaml.
     
     The significand of a floating point number is made of 53 binary
     digits (don't forget the implicit digit), this corresponds to 
     log{_10}(2{^53}) ~ 16 {e decimal} digits.
     
     Only [float] values in the interval \][-2]{^52};2{^52}\[ may have
     a fractional part. {!Float.max_frac_float} is the greatest
     positive [float] with a fractional part.
     
     Any integer value in the interval \[[-2]{^53};2{^53}\] can be
     represented exactly by a [float] value.  {e Integer} arithmetic
     performed in this interval is exact.  {!Float.max_int_arith} is
     2{^53}. *)

end

(** The following type are defined so that they can be used
    in vector modules. The matrix modules are {{!matrices}here}. *)

type m2
(** The type for 2x2 matrices. *)

type m3
(** The type for 3x3 matrices. *)

type m4
(** The type for 4x4 matrices. *)

(** {1:vectors Vectors} 

    An n-dimensional {e vector} [v] is a sequence of n, zero indexed,
    floating point {e components}. We write [v]{_i} the ith component
    of a vector. *)

type v2
(** The type for 2D vectors. *)

type v3
(** The type for 3D vectors. *)

type v4
(** The type for 4D vectors. *)

(** Implemented by all vector types. *)
module type V = sig
  type t
  (** The type for vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!t}. *)

  type m
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val comp : int -> t -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val zero : t
  (** [zero] is the neutral element for {!add}. *)

  val infinity : t
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : t
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> t
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  (** {1:functions Functions} *)

  val neg : t -> t
  (** [neg v] is the inverse vector [-v]. *)

  val add : t -> t -> t
  (** [add u v] is the vector addition [u + v]. *)

  val sub : t -> t -> t
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : t -> t -> t
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : t -> t -> t
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> t -> t
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : t -> t
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : t -> t -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : t -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : t -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : t -> t
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : t -> t 
  (** [homogene v] is the vector [v/(comp (dim - 1) v)] if 
      [comp (dim - 1) v <> 0] and [v] otherwise. *)

  val mix : t -> t -> float -> t
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m -> t -> t
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  (** {1:ops Overridden [Pervasives] operators} *)

  val ( + ) : t -> t -> t 
  (** [u + v] is [add u v]. *)

  val ( - ) : t -> t -> t
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> t -> t 
  (** [t * v] is [smul t v]. *)

  val ( / ) : t -> float -> t 
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> t -> t
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> t -> t
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> t -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> t -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> t -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  t -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> t -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> t -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : t -> t -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> t -> t -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : t -> string
  (** [to_string v] is a textual representation of [v]. *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    t -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses 
      [pp_comp] to print floating point values. *)
end

module V2 : sig
  type t = v2
  (** The type for 2D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v2}. *)

  type m = m2
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations} of 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> v2
  (** [v x y] is the vector [(x y)]. *)

  val comp : int -> v2 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val x : v2 -> float 
  (** [x v] is the x component of [v].*)

  val y : v2 -> float 
  (** [y v] is the y component of [v].*)

  val ox : v2 
  (** [ox] is the unit vector [(1. 0.)]. *)

  val oy : v2 
  (** [oy] is the unit vector [(0. 1.)]. *)

  val zero : v2
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v2
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v2
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v2
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : float * float -> v2
  (** [of_tuple (x, y)] is [V2.v x y]. *)

  val to_tuple : v2 -> float * float
  (** [of_tuple v] is [(V2.x v, V2.y v]). *)

  val of_polar : v2 -> v2 
  (** [of_polar pv] is a vector whose cartesian coordinates [(x, y)]
      correspond to the radial and angular
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinates} [(r, theta)] given by [(V2.x pv, V2.y pv)]. *)

  val to_polar : v2 -> v2 
  (** [to_polar v] is a vector whose coordinates [(r, theta)] are the 
      radial and angular 
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinates} of [v]. [theta] is in \[[-pi;pi]\].*)

  val of_v3 : v3 -> v2
  (** [of_v3 u] is [v (V3.x u) (V3.y u)]. *)

  val of_v4 : v4 -> v2
  (** [of_v4 u] is [v (V4.x u) (V4.y u)]. *)

  (** {1:functions Functions} *)

  val neg : v2 -> v2
  (** [neg v] is the inverse vector [-v]. *)

  val add : v2 -> v2 -> v2
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v2 -> v2 -> v2
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v2 -> v2 -> v2
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v2 -> v2 -> v2
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v2 -> v2
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v2 -> v2
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : v2 -> v2 -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v2 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v2 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v2 -> v2
  (** [unit v] is the unit vector [v/|v|]. *)

  val polar : float -> float -> v2 
  (** [polar r theta] is [V2.of_polar (V2.v r theta)]. *)

  val angle : v2 -> float 
  (** [angle v] is the angular 
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinates} of [v]. The result is in \[[-pi;pi]\]. *)

  val ortho : v2 -> v2 
  (** [ortho v] is [v] rotated by [pi] / 2. *)

  val homogene : v2 -> v2
  (** [homogene v] is the vector [v/v]{_y} if [v]{_y}[ <> 0] and [v] 
      otherwise. *)

  val mix : v2 -> v2 -> float -> v2
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m2 -> v2 -> v2
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  val tr : m3 -> v2 -> v2
  (** [tr m v] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 2D space of the {e vector} [v] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [v] is treated as a vector
      (infinite point, its last coordinate in homogenous space is 0) 
      and is thus translationally invariant. Use {!P2.tr} to
      transform finite points. *)

  (** {1:ops Overridden [Pervasives] operators} *)

  val ( + ) : v2 -> v2 -> v2 
  (** [u + v] is [add u v]. *)

  val ( - ) : v2 -> v2 -> v2
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> v2 -> v2 
  (** [t * v] is [smul t v]. *)

  val ( / ) : v2 -> float -> v2 
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v2 -> v2
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v2 -> v2
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v2 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v2 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v2 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v2 -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> v2 -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v2 -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v2 -> v2 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v2 -> v2 -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v2 -> v2 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> v2 -> v2 -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : v2 -> string
  (** [to_string v] is a textual representation of [v]. *)

  val pp : Format.formatter -> v2 -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    v2 -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses 
      [pp_comp] to print floating point values. *)
end

module V3 : sig
  type t = v3
  (** The type for 3D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v3}. *)

  type m = m3
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> v3
  (** [v x y z] is the vector [(x y z)]. *)

  val comp : int -> v3 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val x : v3 -> float 
  (** [x v] is the x component of [v]. *)

  val y : v3 -> float 
  (** [y v] is the y component of [v]. *)

  val z : v3 -> float 
  (** [z v] is the z component of [v]. *)

  val ox : v3
  (** [ox] is the unit vector [(1. 0. 0.)]. *) 

  val oy : v3
  (** [oy] is the unit vector [(0. 1. 0.)]. *) 

  val oz : v3
  (** [oz] is the unit vector [(0. 0. 1.)]. *) 

  val zero : v3
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v3
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v3
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v3
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : (float * float * float) -> v3
  (** [of_tuple (x, y, z)] is [v x y z]. *)

  val to_tuple : v3 -> (float * float * float)
  (** [to_tuple v] is [(x v, y v, z v)]. *)

  val of_spherical : v3 -> v3 
  (** [of_spherical sv] is the vector whose cartesian coordinates 
      [(x, y, z)] correspond to the radial, azimuth
      angle and zenith angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} [(r, theta, phi)] given by [(V3.x sv, V2.y sv, V3.z sv)]. *)

  val to_spherical : v3 -> v3 
  (** [to_spherical v] is the vector whose coordinate [(r, theta,
      phi)] are the radial, azimuth angle and zenith angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} of [v]. [theta] is in \[[-pi;pi]\] and [phi] in
      \[[0;pi]\]. *)

  val of_v2 : v2 -> z:float -> v3
  (** [of_v2 u z] is [v (V2.x u) (V2.y u) z]. *)

  val of_v4 : v4 -> v3
  (** [of_v4 u z] is [v (V4.x u) (V4.y u) (V4.z u)]. *)

  (** {1:functions Functions} *)

  val neg : v3 -> v3
  (** [neg v] is the inverse vector [-v]. *)

  val add : v3 -> v3 -> v3
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v3 -> v3 -> v3
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v3 -> v3 -> v3
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v3 -> v3 -> v3
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v3 -> v3
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v3 -> v3
  (** [half v] is the half vector [smul 0.5 v]. *)

  val cross : v3 -> v3 -> v3
  (** [cross u v] is the 
      {{:http://mathworld.wolfram.com/CrossProduct.html}cross product} 
      [u x v]. *)

  val dot : v3 -> v3 -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v3 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v3 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v3 -> v3
  (** [unit v] is the unit vector [v/|v|]. *)

  val spherical : float -> float -> float -> v3 
  (** [spherical r theta phi] is [of_spherical (V3.v r theta phi)]. *)

  val azimuth : v3 -> float 
  (** [azimuth v] is the azimuth angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} of [v]. The result is in \[[-pi;pi]\]. *)

  val zenith : v3 -> float 
  (** [zenith v] is the zenith angle
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinates} of [v]. The result is in \[[0;pi]\]. *)

  val homogene : v3 -> v3
  (** [homogene v] is the vector [v/v]{_z} if [v]{_z}[ <> 0] and
      [v] otherwise. *)

  val mix : v3 -> v3 -> float -> v3
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m3 -> v3 -> v3
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  val tr : m4 -> v3 -> v3
  (** [tr m v] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 3D space of the {e vector} [v] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [v] is treated as a vector
      (infinite point, its last coordinate in homogenous space is 0) 
      and is thus translationally invariant. Use {!P3.tr} to
      transform finite points. *)

  (** {1:ops Overridden [Pervasives] operators} *)

  val ( + ) : v3 -> v3 -> v3 
  (** [u + v] is [add u v]. *)

  val ( - ) : v3 -> v3 -> v3
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> v3 -> v3 
  (** [t * v] is [smul t v]. *)

  val ( / ) : v3 -> float -> v3 
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v3 -> v3
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v3 -> v3
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v3 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v3 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v3 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v3 -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> v3 -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v3 -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v3 -> v3 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v3 -> v3 -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v3 -> v3 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> v3 -> v3 -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : v3 -> string
  (** [to_string v] is a textual representation of [v]. *)

  val pp : Format.formatter -> v3 -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    v3 -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses 
      [pp_comp] to print floating point values. *)
end

module V4 : sig
  type t = v4
  (** The type for 4D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v4}. *)

  type m = m4
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of 4D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float -> v4
  (** [v x y z w] is the vector [(x y z w)]. *)

  val comp : int -> v4 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val x : v4 -> float 
  (** [x v] is the x component of [v]. *)

  val y : v4 -> float 
  (** [y v] is the y component of [v]. *)

  val z : v4 -> float 
  (** [z v] is the z component of [v]. *)

  val w : v4 -> float 
  (** [z v] is the z component of [v]. *)

  val ox : v4
  (** [ox] is the unit vector [(1. 0. 0. 0.)]. *) 

  val oy : v4
  (** [oy] is the unit vector [(0. 1. 0. 0.)]. *) 

  val oz : v4
  (** [oz] is the unit vector [(0. 0. 1. 0.)]. *) 

  val ow : v4
  (** [ow] is the unit vector [(0. 0. 0. 1.)]. *) 

  val zero : v4
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v4
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v4
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v4
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : (float * float * float * float) -> v4
  (** [of_tuple (x, y, z, w)] is [v x y z w]. *)

  val to_tuple : v4 -> (float * float * float * float)
  (** [to_tuple v] is [(x v, y v, z v, w v)]. *)

  val of_v2 : v2 -> z:float -> w:float -> v4
  (** [of_v2 u z w] is [v (V2.x u) (V2.y u) z w]. *)

  val of_v3 : v3 -> w:float -> v4
  (** [of_v3 u w] is [v (V3.x u) (V3.y u) (V3.z u) w]. *)

  (** {1:functions Functions} *)

  val neg : v4 -> v4
  (** [neg v] is the inverse vector [-v]. *)

  val add : v4 -> v4 -> v4
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v4 -> v4 -> v4
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v4 -> v4 -> v4
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v4 -> v4 -> v4
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v4 -> v4
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v4 -> v4
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : v4 -> v4 -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v4 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v4 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v4 -> v4
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : v4 -> v4
  (** [homogene v] is the vector [v/v]{_w} if [v]{_w}[ <> 0] and [v] 
      otherwise. *)

  val mix : v4 -> v4 -> float -> v4
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m4 -> v4 -> v4
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  (** {1 Overridden [Pervasives] operators} *)

  val ( + ) : v4 -> v4 -> v4 
  (** [u + v] is [add u v]. *)

  val ( - ) : v4 -> v4 -> v4
  (** [u - v] is [sub u v]. *)

  val ( * ) : float -> v4 -> v4 
  (** [t * v] is [smul t v]. *)

  val ( / ) : v4 -> float -> v4 
  (** [v / t] is [smul (1. /. t) v]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v4 -> v4
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v4 -> v4
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v4 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v4 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v4 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v4 -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> v4 -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v4 -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v4 -> v4 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v4 -> v4 -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v4 -> v4 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> v4 -> v4 -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : v4 -> string
  (** [to_string v] is a textual representation of [v]. *)

  val pp : Format.formatter -> v4 -> unit
  (** [pp ppf v] prints a textual representation of [v] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    v4 -> unit
  (** [pp_f pp_comp ppf v] prints [v] like {!pp} but uses 
      [pp_comp] to print floating point values. *)
end

(** {1:points Points} 

    An n-dimensional {e point} [p] is a vector of the corresponding
    dimension. The components of the vector are the point's {e
    coordinates}.
*)

type p2 = v2
(** The type for 2D points. *)

type p3 = v3
(** The type for 3D points. *)

(** Implemented by all point types. *)
module type P = sig
  type t
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!t}. *)

  type mh
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val o : t
  (** [o] is the point whose coordinates are all zero. *)

  (** {1:functions Functions} *)  

  val mid : t -> t -> t
  (** [mid p q] is the mid point [(p + q)/2]. *)
      
  val tr : mh -> t -> t
  (** [tr m p] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} {!dim} space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point 
      (its last coordinate in homogenous space is 1). *)
end

module P2 : sig
  type t = p2
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!p2}. *)

  type mh = m3
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> p2
  (** [v x y] is the point [(x y)]. *)

  val x : p2 -> float 
  (** [x p] is the x coordinate of [p].*)

  val y : p2 -> float 
  (** [y p] is the y coordinate of [p].*)

  val o : p2
  (** [o] is the point [(0 0)]. *)

  (** {1:functions Functions} *)
  
  val mid : p2 -> p2 -> p2
  (** [mid p q] is the mid point [(p + q)/2]. *)

  val tr : m3 -> p2 -> p2
  (** [tr m p] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 2D space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point 
      (its last coordinate in homogenous space is 1). Use {!V2.tr}
      to transform vectors (infinite points). *)
end

module P3 : sig
  type t = p3
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!p3}. *)

  type mh = m4
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> p3
  (** [v x y z] is the point [(x y z)]. *)

  val x : p3 -> float 
  (** [x p] is the x coordinate of [p].*)

  val y : p3 -> float 
  (** [y p] is the y coordinate of [p].*)

  val z : p3 -> float 
  (** [y p] is the z coordinate of [p].*)

  val o : p3
  (** [o] is the point [(0 0 0)]. *)

  (** {1:functions Functions} *)
  
  val mid : p3 -> p3 -> p3
  (** [mid p q] is the mid point [(p + q)/2]. *)

  val tr : m4 -> p3 -> p3
  (** [tr m p] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 3D space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point 
      (its last coordinate in homogenous space is 1). Use {!V3.tr}
      to transform vectors (infinite points). *)
end

(** {1:quaternions Quaternions} 

    Unit {{:http://mathworld.wolfram.com/Quaternion.html}quaternions}
    represent rotations in 3D space. They allow to smoothly
    interpolate between orientations. A quaternion is a 4D vector,
    whose components [x], [y], [z], [w] represents the quaternion
    [x]i+ [y]j + [z]k + [w]. *)

type quat = v4
(** The type for quaternions. *)

module Quat : sig

  type t = quat
  (** The type for quaternions. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float -> quat
  (** [v x y z w] is the quaternion [x]i+ [y]j + [z]k + [w]. *) 

  val zero : quat
  (** [zero] is the zero quaternion. *)  

  val id : quat
  (** [id] is the identity quaternion [1]. *)

  (** {1:functions Functions} *)

  val mul : quat -> quat -> quat
  (** [mul q r] is the quaternion multiplication [q * r]. *)

  val conj : quat -> quat
  (** [conj q] is the 
      {{:http://mathworld.wolfram.com/QuaternionConjugate.html}quaternion 
      conjugate} [q*]. *)

  val unit : quat -> quat
  (** [unit q] is the unit vector [q/|q|] (same as {!V4.unit}). *) 

  val inv : quat -> quat
  (** [inv q] is the quaternion inverse [q]{^ -1}. *)

  val slerp : quat -> quat -> float -> quat
  (** [slerp q r t] is the spherical linear interpolation between [q]
      and [r] at [t]. Non commutative, torque minimal and constant
      velocity. *)

  val squad : quat -> quat -> quat -> quat -> float -> quat
  (** [squad q cq cr r t] is the spherical cubic interpolation
      between [q] and [r] at [t]. [cq] and [cr] indicate the tangent
      orientations at [q] and [r]. *)

  val nlerp : quat -> quat -> float -> quat
  (** [nlerp q r t] is the normalized linear interpolation between [q]
      and [r] at [t].  Commutative, torque minimal and inconstant
      velocity. *)

  (** {1:transformations3d 3D space transformations} *)

  val of_m3 : m3 -> quat
  (** [of_m3 m] is the unit quaternion for the rotation in [m]. *)

  val of_m4 : m4 -> quat
  (** [of_m4 m] is the unit quaternion for the rotation in the 3x3
      top left matrix in [m]. *)

  val rot_map : v3 -> v3 -> quat
  (** Unit quaternion for the rotation, see {!M3.rot_map}. *)

  val rot_axis : v3 -> float -> quat 
  (** Unit quaternion for the rotation, see {!M3.rot_axis}. *)

  val rot_zyx : v3 -> quat
  (** Unit quaternion for the rotation, see {!M3.rot_zyx}. *)

  val to_rot_axis : quat -> v3 * float
  (** [to_rot_axis q] is the rotation axis and angle of the {e unit} 
      quaternion [q].*)

  val to_rot_zyx : quat -> v3
  (** [to_rot_zyx q] is the x, y, z axis angles of the {e unit} 
      quaternion [q]. *)
  
  val apply3 : quat -> v3 -> v3 
  (** [apply3 q v] applies the 3D rotation of the {e unit} quaternion
      [q] to the vector (or point) [v]. *)

  val apply4 : quat -> v4 -> v4
  (** [apply4 q v] apply the 3D rotation of the {e unit} quaternion
      [q] to the homogenous vector (or point) [v]. *)
end

(** {1:matrices Matrices} 

    An {e m}x{e n} matrix [a] is an array of {e m} rows and {e n}
    columns of floating point {e elements}. We write [a]{_ij} the
    element of [a] located at the ith row and jth column.

    Matrix constructors specify matrix elements in
    {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order}
    so that matrix definitions look mathematically natural with proper
    code indentation. However elements are {e stored} and {e
    iterated} over in
    {{:http://en.wikipedia.org/wiki/Column-major_order}column-major
    order}. *)

(** Implemented by all (square) matrix types. *)
module type M = sig
  type t
  (** The type for matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v 
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val el : int -> int -> t -> float
  (** [el i j a] is the element [a]{_[ij]}. 

      @raise Invalid_argument if [i] or [j] is not in \[[0;]{!dim}\[.*)


  val row : int -> t -> v
  (** [row i a] is the [i]th row of [a].

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> t -> v
  (** [col j a] is the [j]th column of [a]. 

      @raise Invalid_argument if [j] is not in \[[0;]{!dim}\[.*)

  val zero : t
  (** [zero] is the neutral element for {!add}. *)

  val id : t
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  (** {1:functions Functions} *)

  val neg : t -> t
  (** [neg a] is the negated matrix [-a]. *)

  val add : t -> t -> t
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : t -> t -> t
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : t -> t -> t
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : t -> t -> t
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : t -> t -> t
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> t -> t
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : t -> t
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : t -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : t -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : t -> t
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> t -> t
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> t -> t
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> t -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> t -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> t -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  t -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> t -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> t -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : t -> t -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> t -> t -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : t -> string
  (** [to_string a] is a textual representation of [a]. *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    t -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses 
      [pp_e] to print floating point values. *)
end

module M2 : sig
  type t = m2
  (** The type for 2D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v2
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> 
          float -> float -> m2
  (** [v e00 e01 e10 e11] is a matrix whose components are 
      specified in     
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v2 -> v2 -> m2
  (** [of_rows r0 r1] is the matrix whose rows are [r0] and [r1]. *)

  val of_cols : v2 -> v2 -> m2
  (** [of_cols c0 c1] is the matrix whose columns are [c0] and [c1]. *)

  val el : int -> int -> m2 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      @raise Invalid_argument if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m2 -> v2
  (** [row i a] is the [i]th row of [a].

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m2 -> v2
  (** [col j a] is the [j]th column of [a]. 

      @raise Invalid_argument if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m2
  (** [zero] is the neutral element for {!add}. *)

  val id : m2
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m3 : m3 -> m2
  (** [of_m3 m] extracts the 2D linear part (top-left 2x2 matrix) of [m]. *)

  val of_m4 : m4 -> m2
  (** [of_m4 m] extracts the 2D linear part (top-left 2x2 matrix) of [m]. *)

  (** {1:functions Functions} *)

  val neg : m2 -> m2
  (** [neg a] is the negated matrix [-a]. *)

  val add : m2 -> m2 -> m2
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m2 -> m2 -> m2
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m2 -> m2 -> m2
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : m2 -> m2 -> m2
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m2 -> m2 -> m2
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m2 -> m2
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m2 -> m2
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m2 -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : m2 -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : m2 -> m2
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *) 

  val rot : float -> m2
  (** [rot theta] rotates 2D space around the origin by [theta]. *)

  val scale : v2 -> m2
  (** [scale s] scales 2D space in the [x] and [y] dimensions
      according to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m2 -> m2
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m2 -> m2
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m2 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m2 -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m2 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m2 -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> m2 -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m2 -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m2 -> m2 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m2 -> m2 -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m2 -> m2 -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m2 -> m2 -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : m2 -> string
  (** [to_string a] is a textual representation of [a]. *)

  val pp : Format.formatter -> m2 -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    m2 -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses 
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m2 -> float
  val e01 : m2 -> float
  val e10 : m2 -> float
  val e11 : m2 -> float
end

module M3 : sig
  type t = m3
  (** The type for 3D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v3
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> 
          float -> float -> float -> 
          float -> float -> float -> m3
  (** [v e00 e01 e02 e10 e11 e12 e20 e21 e22] is a matrix whose components 
      are specified in     
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v3 -> v3 -> v3 -> m3
  (** [of_rows r0 r1 r2] is the matrix whose rows are [r0], [r1] and [r2]. *)

  val of_cols : v3 -> v3 -> v3 -> m3
  (** [of_cols c0 c1 c2] is the matrix whose columns are [c0], [c1] and [c2]. *)

  val el : int -> int -> m3 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      @raise Invalid_argument if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m3 -> v3
  (** [row i a] is the [i]th row of [a].

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m3 -> v3
  (** [col j a] is the [j]th column of [a]. 

      @raise Invalid_argument if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m3
  (** [zero] is the neutral element for {!add}. *)

  val id : m3
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m2_v2 : m2 -> v2 -> m3
  (** [of_m2_v2 m v] is the matrix whose first two rows are
      those of [m],[v] side by side and the third is [0 0 1]. *)

  val of_m4 : m4 -> m3
  (** [of_m4 m] extracts the 3D linear part (top-left 3x3 matrix) of [m]. *)

  val of_quat : quat -> m3
  (** [of_quat q] is the rotation of the {e unit} quaternion [q] as
      3D matrix. *)

  (** {1:functions Functions} *)

  val neg : m3 -> m3
  (** [neg a] is the negated matrix [-a]. *)

  val add : m3 -> m3 -> m3
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m3 -> m3 -> m3
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m3 -> m3 -> m3
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : m3 -> m3 -> m3
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m3 -> m3 -> m3
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m3 -> m3
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m3 -> m3
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m3 -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : m3 -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : m3 -> m3
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *) 

  val move : v2 -> m3
  (** [move d] translates 2D space in the x and y dimensions according 
      to [d]. *)

  val rot : float -> m3
  (** See {!M2.rot}. *)

  val scale2 : v2 -> m3
  (** See {!M2.scale}. *)

  val rigid : move:v2 -> rot:float -> m3 
  (** [rigid move theta] is the rigid body transformation of 
      2D space that rotates by [theta] and then translates by [move]. *)

  val srigid : move:v2 -> rot:float -> scale:v2 -> m3 
  (** [srigid move theta scale] is like {!rigid} but starts by
      scaling according to [scale]. *)
      
  (** {1:transformations3d 3D space transformations} *) 

  val rot_map : v3 -> v3 -> m3 
  (** [rot_map u v] rotates 3D space to map the {e unit} vector [u] on
      the {e unit} vector [v]. *)

  val rot_axis : v3 -> float -> m3
  (** [rot_axis v theta] rotates 3D space by [theta] around 
      the {e unit} vector [v]. *)

  val rot_zyx : v3 -> m3 
  (** [rot_zyx r] rotates 3D space first by [V3.x r] around the
      x-axis, then by [V3.y r] around the y-axis and finally by [V3.z
      r] around the z-axis. *)

  val scale : v3 -> m3
  (** [scale s] scales 3D space in the [x], [y] and [z] dimensions
      according to [s]. *)
 
  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m3 -> m3
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m3 -> m3
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m3 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m3 -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m3 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m3 -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> m3 -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m3 -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m3 -> m3 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m3 -> m3 -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m3 -> m3 -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m3 -> m3 -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : m3 -> string
  (** [to_string a] is a textual representation of [a]. *)

  val pp : Format.formatter -> m3 -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    m3 -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses 
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m3 -> float
  val e01 : m3 -> float
  val e02 : m3 -> float
  val e10 : m3 -> float
  val e11 : m3 -> float
  val e12 : m3 -> float
  val e20 : m3 -> float
  val e21 : m3 -> float
  val e22 : m3 -> float
end

module M4 : sig
  type t = m4
  (** The type for 4D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v4
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float ->
          float -> float -> float -> float ->
          float -> float -> float -> float ->
          float -> float -> float -> float -> m4
  (** [v e00 e01 e02 e03 e10 e11 e12 e13 e20 e21 e22 e23 e30 e31 e32 e33] 
      is a matrix whose components are specified in     
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v4 -> v4 -> v4 -> v4 -> m4
  (** [of_rows r0 r1 r2 r3] is the matrix whose rows are [r0], [r1], [r2] and 
      [r3]. *)

  val of_cols : v4 -> v4 -> v4 -> v4 -> m4
  (** [of_cols c0 c1 c2 c3] is the matrix whose columns are [c0], [c1], [c2] 
      and [c3]. *)

  val el : int -> int -> m4 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      @raise Invalid_argument if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m4 -> v
  (** [row i a] is the [i]th row of [a].

      @raise Invalid_argument if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m4 -> v
  (** [col j a] is the [j]th column of [a]. 

      @raise Invalid_argument if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m4
  (** [zero] is the neutral element for {!add}. *)

  val id : m4
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m3_v3 : m3 -> v3 -> m4 
  (** [of_m3_v3 m v] is the matrix whose first three rows are
      those of [m],[v] side by side and the fourth is [0 0 0 1]. *)

  val of_quat : quat -> m4
  (** [to_quat q] is the rotation of the {e unit} quaternion [q] as
      4D matrix. *)

  (** {1:functions Functions} *)

  val neg : m4 -> m4
  (** [neg a] is the negated matrix [-a]. *)

  val add : m4 -> m4 -> m4
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m4 -> m4 -> m4
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m4 -> m4 -> m4
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : m4 -> m4 -> m4
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m4 -> m4 -> m4
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m4 -> m4
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m4 -> m4
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m4 -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : m4 -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : m4 -> m4
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations3d 3D space transformations} *)

  val move : v3 -> m4
  (** [move d] translates 3D space in the x, y and z dimensions according
      to [d]. *)

  val rot_map : v3 -> v3 -> m4
  (** See {!M3.rot_map}. *)

  val rot_axis : v3 -> float -> m4
  (** See {!M3.rot_axis}. *)

  val rot_zyx : v3 -> m4
  (** See {!M3.rot_zyx}. *)

  val scale3 : v3 -> m4
  (** See {!M3.scale}. *)

  val rigid : move:v3 -> rot:v3 * float -> m4
  (** [rigid move rot] is the rigid body transformation
      of 3D space that rotates by the axis/angle [rot]
      and then translates by [move]. *)

  val rigidq : move:v3 -> rot:quat -> m4
  (** [rigid move rot] is the rigid body transformation of 3D space
      that rotates by the quaternion [rot] and then translates by
      [move]. *)

  val srigid : move:v3 -> rot:v3 * float -> scale:v3 -> m4
  (** [rigid scale move rot scale] is like {!rigid} but starts
      by scaling according to [scale]. *)

  val srigidq : move:v3 -> rot:quat -> scale:v3 -> m4
  (** [srigid move rot scale] is like {!rigidq} but starts by scaling 
      according to [scale]. *)

(** {1:projections3d 3D space projections}
    
    Projection matrices assume a right-handed coordinate
    system with the eye at the origin looking down the z-axis. *)

  val ortho : left:float -> right:float -> bottom:float -> top:float -> 
    near:float -> far:float -> m4
  (** [ortho left right bottom top near far] maps the axis aligned box with 
      corners [(left, bottom, -near)] and [(right, top, -far)] to 
      the axis aligned cube with corner [(-1, -1, -1)] and [(1, 1, 1)]. *) 

  val persp : left:float -> right:float -> bottom:float -> top:float -> 
    near:float -> far:float -> m4
  (** [persp left right bottom top near far] maps the frustum with top of 
      the underlying pyramid at the origin, near clip rectangle corners
      [(left, bottom, -near)], [(right, top, -near)] and far plane at
      [-far] to the axis aligned cube with corners [(-1, -1, -1)] and 
      [(1,1,1)]. *)

(*
     val persp_fov : fovy:float -> aspect:float -> near:float ->
     far:float -> m4
  (** Perspective projection. [fovy] is the field of view, in radians,
      along the y-axis.  [aspect] is the ratio [w/h] of the near clip
      rectangle. [near] and [far] are {e distances} to the near and
      far clip planes.  

      Let [h = 2 * near * (tan fovy/2)] and [w = aspect * h]. The
      transform maps the {e symmetric} frustum with top of the
      underlying pyramid at the origin, near clip rectangle corners
      [(-w/2,-h/2,-near)], [(w/2,h/2,-near)] and far plane at
      [-far] to the cube with corners [(-1, -1, -1)] and [(1,1,1)]. *)
*)


  (** {1:transformations4d 4D space transformations} *)

  val scale : v4 -> m4
  (** [scale s] scales 4D space in the x, y, z and w dimensions according
      to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m4 -> m4
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m4 -> m4
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m4 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m4 -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m4 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m4 -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> m4 -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m4 -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m4 -> m4 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m4 -> m4 -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m4 -> m4 -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m4 -> m4 -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : m4 -> string
  (** [to_string a] is a textual representation of [a]. *)

  val pp : Format.formatter -> m4 -> unit
  (** [pp ppf a] prints a textual representation of [a] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    m4 -> unit
  (** [pp_f pp_e ppf a] prints [a] like {!pp} but uses 
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m4 -> float
  val e01 : m4 -> float
  val e02 : m4 -> float
  val e03 : m4 -> float
  val e10 : m4 -> float
  val e11 : m4 -> float
  val e12 : m4 -> float
  val e13 : m4 -> float
  val e20 : m4 -> float
  val e21 : m4 -> float
  val e22 : m4 -> float
  val e23 : m4 -> float
  val e30 : m4 -> float
  val e31 : m4 -> float
  val e32 : m4 -> float
  val e33 : m4 -> float
end

(** {1:sizes Sizes} 
    
    An n-dimensional {e size} [s] represents extents in n-dimensional space.
*)

type size2 = v2
(** The type for sizes in 2D space. *)

type size3 = v3
(** The type for sizes in 3D space. *)

(** Implemented by all size types. *)
module type Size = sig
  type t
  (** The type for sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!t}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val zero : t
  (** [zero] is the zero size, zero extent in each dimension. *)

  val unit : t
  (** [unit] is the unit size, one extent in each dimension. *)
end

module Size2 : sig
(** In 2D space, {e width} is the extent along the x-axis and 
    {e height} the extent along the y-axis.

    {1:top  }*)

  type t = size2
  (** The type for 2D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size2}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> size2
  (** [v w h] is a size of width [w] and height [h]. *)

  val w : size2 -> float
  (** [w s] is the width of [s]. *)

  val h : size2 -> float
  (** [h s] is the height of [s]. *)

  val zero : size2
  (** [zero] is the zero size, zero width and height. *)

  val unit : size2
  (** [unit] is the unit size, one width and height. *)
end

module Size3 : sig
(** In 3D space, {e width} is the extent along the x-axis, 
    {e height} the extent along the y-axis and {e depth}
    the extent along the z-axis. 

    {1:top  }*)

  type t = size3
  (** The type for 3D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size3}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> size3
  (** [v w h d] is a size of width [w], height [h] and depth [d]. *)

  val w : size3 -> float
  (** [w s] is the width of [s]. *)

  val h : size3 -> float
  (** [h s] is the height of [s]. *)

  val d : size3 -> float
  (** [d s] is the depth of [s]. *)

  val zero : size3
  (** [zero] is the zero size, zero width, height and depth. *)

  val unit : size3
  (** [unit] is the unit size, one width, height and depth. *)
end

(** {1:aboxes Axis-aligned boxes} 

    An n-dimensional axis-aligned box [b] is defined by an
    n-dimensional point [o], its {e origin}, and an n-dimensional size
    [s]. Operations on boxes with negative sizes are undefined.

    The space S([b]) spanned by [b] is \[[o]{_0};
    [o]{_0} + [s]{_0}\] x ... x \[[o]{_n-1}; [o]{_n-1} +
    [s]{_n-1}\]. The extremum points of this space are the box's {e
    corners}. There is a distinguished n-dimensional [empty] box such
    that S([empty]) is empty.  *)

type box2
(** The type for 2D axis-aligned boxes 
    ({{:http://mathworld.wolfram.com/Rectangle.html}rectangles}). *)

type box3
(** The type for 3D axis-aligned boxes
    ({{:http://mathworld.wolfram.com/Cuboid.html}cuboids}). *)

(** Implemented by all axis-aligned box types. *)
module type Box = sig
  type t
  (** The type for boxes. *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!t}. *)

  type v 
  (** The type for {!dim} vectors. *)

  type p 
  (** The type for {!dim} points. *)

  type size 
  (** The type for {!dim} sizes. *)

  type m
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p -> size -> t
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : p -> size -> t
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and 
      size is [size]. *)

  val empty : t
  (** [empty] is {e the} empty box. *)

  val o : t -> p
  (** [o b] is the origin of [b].

      @raise Invalid_argument on {!empty} *)

  val size : t -> size
  (** [size b] is the size of [b]. 

      @raise Invalid_argument on {!empty} *)

  val zero : t
  (** [zero] is a box whose origin and size is zero. *)

  val unit : t 
  (** [unit] is the unit box which extends from zero to 
      one in all dimensions. *)

  val of_pts : p -> p -> t
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  (** {1:functions Functions} *)

  val min : t -> p
  (** [min b] is the smallest point of [b] (its origin). 

      @raise Invalid_argument on {!empty} *)

  val max : t -> p
  (** [max b] is the greatest point of [b] (its size added to the origin). 

      @raise Invalid_argument on {!empty} *)

  val mid : t -> p 
  (** [mid b] is the mid point between [min] and [max]. 

      @raise Invalid_argument on {!empty} *)

  val area : t -> float
  (** [area b] is the surface area of [b]. *)

  val inter : t -> t -> t
  (** [inter b b'] is a box whose space is the intersection of S([b]) 
      and S([b']). *)

  val union : t -> t -> t 
  (** [union b b'] is the smallest box whose space contains 
      S([b]) and S([b']). *)

  val inset : v -> t -> t 
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the resulting size is negative returns {!empty}.  Returns
      {!empty} on {!empty}. *)

  val round : t -> t 
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v -> t -> t 
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m -> t -> t 
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> t -> t 
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1 Predicates and comparisons} *)

  val is_empty : t -> bool 
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : t -> bool 
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val isects : t -> t -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : t -> t -> bool 
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p -> t -> bool 
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : t -> t -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool 
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> t -> t -> int 
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : t -> string
  (** [to_string b] is a textual representation of [b]. *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    t -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses 
      [pp_fl] to print floating point values. *)
end

module Box2 : sig
  type t = box2
  (** The type for 2D boxes 
      ({{:http://mathworld.wolfram.com/Rectangle.html}rectangles}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box2}. *)

  type v = v2
  (** The type for 2D vectors. *)

  type p = p2
  (** The type for 2D points. *)

  type size = size2
  (** The type for 2D sizes. *)

  type m = m2
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations} of 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p2 -> size2 -> box2
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : p2 -> size2 -> t
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and 
      size is [size]. *)

  val empty : box2
  (** [empty] is {e the} empty box. *)

  val o : box2 -> p2
  (** [o b] is the origin of [b].

      @raise Invalid_argument on {!empty} *)

  val ox : box2 -> float 
  (** [ox b] is [V2.x (o b)]. *)

  val oy : box2 -> float 
  (** [oy b] is [V2.y (o b)]. *)

  val size : box2 -> size
  (** [size b] is the size of [b]. 

      @raise Invalid_argument on {!empty} *)

  val w : box2 -> float 
  (** [w b] is [Size2.w (size b)]. *)

  val h : box2 -> float 
  (** [h b] is [Size2.h (size b)]. *)

  val zero : box2
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box2 
  (** [unit] is the unit box which extends from zero to 
      one in all dimensions. *)

  val of_pts : p2 -> p2 -> box2
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  (** {1:functions Functions} *)

  val min : box2 -> p2
  (** [min b] is the smallest point of [b] (its origin). 

      @raise Invalid_argument on {!empty} *)

  val minx : box2 -> float 
  (** [minx b] is [V2.x (min b)]. *)

  val miny : box2 -> float 
  (** [miny b] is [V2.y (min b)]. *)

  val max : box2 -> p2
  (** [max b] is the greatest point of [b] (its size added to the origin). 

      @raise Invalid_argument on {!empty} *)

  val maxx : box2 -> float 
  (** [maxx b] is [V2.x (max b)]. *)

  val maxy : box2 -> float 
  (** [maxy b] is [V2.y (max b)]. *)

  val mid : box2 -> p2 
  (** [mid b] is the mid point between [min] and [max]. 

      @raise Invalid_argument on {!empty} *)

  val midx : box2 -> float 
  (** [midx b] is [V2.x (mid b)]. *)

  val midy : box2 -> float 
  (** [midy b] is [V2.y (mid b)]. *)

  val bottom_left : box2 -> p2
  (** [bottom_left b] is the bottom-left corner of [b].

      @raise Invalid_argument on {!empty} *)

  val bottom_right : box2 -> p2
  (** [bottom_right b] is the bottom-right corner of [b].

      @raise Invalid_argument on {!empty} *)

  val top_left : box2 -> p2
  (** [top_left b] is the top-left corner of [b].

      @raise Invalid_argument on {!empty} *)

  val top_right : box2 -> p2
  (** [top_right b] is the top-right corner of [b].

      @raise Invalid_argument on {!empty} *)

  val area : box2 -> float
  (** [area b] is the surface area of [b]. *)

  val inter : box2 -> box2 -> box2
  (** [inter b b'] is a box whose space is the intersection of S([b]) 
      and S([b']). *)

  val union : box2 -> box2 -> box2 
  (** [union b b'] is the smallest box whose space contains 
      S([b]) and S([b']). *)

  val inset : v2 -> box2 -> box2 
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the resulting size is negative returns {!empty}.  Returns
      {!empty} on {!empty}. *)

  val round : box2 -> box2 
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v2 -> box2 -> box2 
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m2 -> box2 -> box2 
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m3 -> box2 -> box2 
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 2D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box2 -> box2 
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1 Predicates and comparisons} *)

  val is_empty : box2 -> bool 
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box2 -> bool 
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val is_seg : box2 -> bool 
  (** [is_seg b] is [true] iff [b] is not {!empty} and its size is 
      equal to 0 in exactly one dimension. *)

  val isects : box2 -> box2 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box2 -> box2 -> bool 
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p2 -> box2 -> bool 
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box2 -> box2 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box2 -> box2 -> bool 
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box2 -> box2 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> box2 -> box2 -> int 
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : box2 -> string
  (** [to_string b] is a textual representation of [b]. *)

  val pp : Format.formatter -> box2 -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    box2 -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses 
      [pp_fl] to print floating point values. *)
end

module Box3 : sig
  type t = box3
  (** The type for 3D boxes
      ({{:http://mathworld.wolfram.com/Cuboid.html}cuboids}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box3}. *)

  type v = v3
  (** The type for 3D vectors. *)

  type p = p3
  (** The type for 3D points. *)

  type size = size3
  (** The type for 3D sizes. *)

  type m = m3
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations} of 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p3 -> size3 -> box3
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val v_mid : p3 -> size3 -> t
  (** [v_mid mid size] is a box whose {!mid} point is [mid] and 
      size is [size]. *)

  val empty : box3
  (** [empty] is {e the} empty box. *)

  val o : box3 -> p3
  (** [o b] is the origin of [b].

      @raise Invalid_argument on {!empty} *)

  val ox : box3 -> float 
  (** [ox b] is [V3.x (o b)]. *)

  val oy : box3 -> float 
  (** [oy b] is [V3.y (o b)]. *)

  val oz : box3 -> float 
  (** [oz b] is [V3.z (o b)]. *)

  val size : box3 -> size3
  (** [size b] is the size of [b]. 

      @raise Invalid_argument on {!empty} *)

  val w : box3 -> float 
  (** [w b] is [Size3.w (size b)]. *)

  val h : box3 -> float 
  (** [h b] is [Size3.h (size b)]. *)

  val d : box3 -> float 
  (** [d b] is [Size3.d (size b)]. *)

  val zero : box3
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box3 
  (** [unit] is the unit box which extends from zero to 
      one in all dimensions. *)

  val of_pts : p3 -> p3 -> box3
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  (** {1:functions Functions} *)

  val min : box3 -> p3
  (** [min b] is the smallest point of [b] (its origin). 

      @raise Invalid_argument on {!empty} *)

  val minx : box3 -> float 
  (** [minx b] is [V3.x (min b)]. *)

  val miny : box3 -> float 
  (** [miny b] is [V3.y (min b)]. *)

  val minz : box3 -> float 
  (** [minz b] is [V3.z (min b)]. *)

  val max : box3 -> p3
  (** [max b] is the greatest point of [b] (its size added to the origin). 

      @raise Invalid_argument on {!empty} *)

  val maxx : box3 -> float 
  (** [maxx b] is [V3.x (max b)]. *)

  val maxy : box3 -> float 
  (** [maxy b] is [V3.y (max b)]. *)

  val maxz : box3 -> float 
  (** [maxz b] is [V3.z (max b)]. *)

  val mid : box3 -> p3 
  (** [mid b] is the mid point between [min] and [max]. 

      @raise Invalid_argument on {!empty} *)

  val midx : box3 -> float 
  (** [midx b] is [V3.x (mid b)]. *)

  val midy : box3 -> float 
  (** [midy b] is [V3.y (mid b)]. *)

  val midz : box3 -> float 
  (** [midz b] is [V3.z (mid b)]. *)

  val area : box3 -> float
  (** [area b] is the surface area of [b]. *)

  val volume : box3 -> float 
  (** [volume b] is the volume of [b]. *)

  val inter : box3 -> box3 -> box3
  (** [inter b b'] is a box whose space is the intersection of S([b]) 
      and S([b']). *)

  val union : box3 -> box3 -> box3 
  (** [union b b'] is the smallest box whose space contains 
      S([b]) and S([b']). *)

  val inset : v3 -> box3 -> box3 
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the resulting size is negative returns {!empty}.  Returns
      {!empty} on {!empty}. *)

  val round : box3 -> box3 
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v3 -> box3 -> box3 
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m3 -> box3 -> box3 
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m4 -> box3 -> box3 
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 3D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box3 -> box3 
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1 Predicates and comparisons} *)

  val is_empty : box3 -> bool 
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box3 -> bool 
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val is_plane : box3 -> bool 
  (** [is_plane b] is [true] iff the size of [b] is equal to 0 in exactly
      one dimension. *)

  val is_seg : box3 -> bool 
  (** [is_seg b] is [true] iff [b] is not {!empty} and its size is 
      equal to 0 in exactly two dimensions. *)

  val isects : box3 -> box3 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box3 -> box3 -> bool 
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p3 -> box3 -> bool 
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box3 -> box3 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box3 -> box3 -> bool 
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box3 -> box3 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> box3 -> box3 -> int 
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : box3 -> string
  (** [to_string b] is a textual representation of [b]. *)

  val pp : Format.formatter -> box3 -> unit
  (** [pp ppf b] prints a textual representation of [b] on [ppf]. *)

  val pp_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    box3 -> unit
  (** [pp_f pp_fl ppf b] prints [b] like {!pp} but uses 
      [pp_fl] to print floating point values. *)
end

(** {1:colors Colors} *)

type color = v4
(** The type for colors, see  {{!Color.t}details}. *)

(** Colors and color profiles.

    [Color] provides some function to operate on {{!t}color} values
    and basic support for ICC based {{!profile}color profiles} to 
    precisely specify how to interpret raw color samples.

    {3 References.}
    {ul
    {- Charles Poynton. 
       {e {{:http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html}
       Frequently asked questions about color}}. 2006}
    {- Charles Poynton. 
       {e {{:http://www.poynton.com/PDFs/Guided_tour.pdf}A guided tour of 
       color space}}. 1997}
    {- Bruce MacEvoy. 
       {{:http://www.handprint.com/LS/CVS/color.html}Color
       vision} and
      {{:http://www.handprint.com/HP/WCL/color7.html}modern color models}.}
    {- International Color Consortium. 
       {e {{:http://www.color.org/icc_specs2.xalter}ICC.1:2010-12 Image 
       technology colour management - Architecture, profile format, and 
       data structure}}. 2010.}} *)
module Color : sig

  (** {1:colors Constructors, accessors and constants} *)

  type t = color
  (** The type for colors in a device independent RGB color space with
      an alpha component. The color space is defined by a D65 white
      point and the ITU-R BT.709 primaries (corresponds to a {e
      linearized}
      {{:http://www.color.org/chardata/rgb/srgb.xalter}sRGB} space).
      The {e alpha} component represent the color's opacity ranging
      from [0.], a fully transparent color, to [1.] a completly opaque
      one. *)

  type stops = (float * color) list
  (** The type for color stops. A piecewise linear color curve. *)  

  val v : float -> float -> float -> float -> color
  (** [v r g b a] is the {e linear} sRGB color [(r, g, b, a)] as 
      a color value. *)

  val v_srgb : ?a:float -> float -> float -> float -> color
  (** [v r g b ~a] is the sRGB color [(r, g, b, a)] converted to a color 
      value. *)

  val v_srgbi : ?a:float -> int -> int -> int -> color 
  (** [v_srgbi r g b ~a] is the sRGB color [(r,g,b,a)] converted to 
      a color value by [(v_srgb (float r /. 255.) (float g /. 255.) 
      (float b /. 255.) ~a]) *)

  val r : color -> float 
  (** [r c] is the red component of [c]. *)

  val g : color -> float
  (** [g c] is the green component of [c]. *)

  val b : color -> float
  (** [b c] is the blue component of [c]. *)

  val a : color -> float
  (** [a c] is the alpha component of [c]. *)

  val void : color
  (** [void] is [(v 0. 0. 0. 0.)] an invisible color. *)

  val black : color
  (** [black] is [(v 0. 0. 0. 1.)] *)

  val gray : ?a:float -> float -> color 
  (** [gray a g] is the sRGB color [(g, g, g, a)] converted to color a 
      value. *)

  val white : color
  (** [white] is [(v 1. 1. 1. 1.)] *)

  val red : color
  (** [red] is [(v 1. 0. 0. 1.)] *)

  val green : color
  (** [green] is [(v 0. 1. 0. 1.)] *)

  val blue : color
  (** [blue] is [(v 0. 0. 1. 1.)] *)

  (** {1 Functions} *)

  val blend : color -> color -> color 
  (** [blend src dst] is [src] blended over [dst] using
      source over destination alpha blending. See Alvy Ray Smith. {e
      {{:http://alvyray.com/Memos/MemosCG.htm#ImageCompositing}Image 
       compositing fundamentals}}. 1995. *)
      
  val clamp : color -> color 
  (** [clamp c] is [c] with all components clamped to \[[0;1]\]. [nan] 
      components are left untouched. *)

  val with_a : color -> float -> color
  (** [with_a c a] is the same color as [c] but with the alpha 
      component [a]. *)

  (** {1:conversions Color conversions} 

      {b Note.} In the following conversions all color spaces carry an
      alpha component.  The alpha component is always left untouched
      by the conversions. *)

  (** {2:srgb sRGB} *)

  type srgb = v4
  (** The type for colors in the 
     {{:http://www.color.org/chardata/rgb/srgb.xalter}sRGB} color space 
     with an alpha component. This is the color space used, for example,
     by CSS. *)

  val of_srgb : srgb -> color 
  (** [of_srgb c] is the sRGB color [c] as a [Gg] color. *)

  val to_srgb : color -> srgb
  (** [to_srgb c] is the [Gg] color [c] as a sRGB color. *)

  (** {2:luv CIE L*u*v*} *)

  type luv = v4
  (** The type for colors in the CIE L*u*v* color space with a D65 reference
      white point and an alpha component. The meaning and range of the 
      components is:
      {ul
      {- L* is lightness in the range [0.] to [100.]}
      {- u*'s practical range is [-134.] to [220.]} 
      {- v*'s practical range is [-140.] to [122.]}} *)

  val of_luv : luv -> color 
  (** [of_luv c] is the L*u*v* color [c] as a [Gg] color. *)

  val to_luv : color -> luv
  (** [to_luv c] is the [Gg] color [c] as a L*u*v* color. *)

  (** {2:lch_uv CIE L*C*h{_uv}} *)

  type lch_uv = v4
  (** The type for colors in the CIE L*C*h{_uv} color space with a 
      D65 reference white point and an alpha component. This color 
      space is CIE L*u*v* with polar coordinates, the meaning and range 
      of the components is:
     {ul
     {- L* is the lightness in the range [0.] to [100.]}
     {- C* represents chroma, in the range [0.] to [260.77] in practice.}
     {- h represents hue in degrees in the range [0.] to [2pi].}} *)

  val of_lch_uv : lch_uv -> color
  (** [of_lch_uv c] is the L*C*h{_uv} color [c] as a [Gg] color. *)

  val to_lch_uv : color -> lch_uv
  (** [to_lch_uv c] is the [Gg] color [c] as a L*C*h{_uv}. *)

  (** {2:lab CIE L*a*b*} *)

  type lab = v4
  (** The type for colors in the CIE L*a*b* color space with a D50 reference
      white point and an alpha component. The meaning and range of the 
      components is:
      {ul
      {- L* is lightness in the range [0.] to [100.]}
      {- a* and b*'s practical range is [-128.] to [127.]}} *)

  val of_lab : v4 -> color 
  (** [of_lab c] is the L*a*b* color [c] as a [Gg] color value. *)

  val to_lab : color -> v4
  (** [to_lab c] is the [Gg] color [c] as a L*a*b* color. *)

  (** {2:lch_ab CIE L*C*h{_ab}} *)

  type lch_ab = v4
  (** The type for colors in the CIE L*C*h*{_ab} color space with a 
      D50 reference white point and an alpha component. This color 
      space is CIE L*a*b* with polar coordinates, the meaning and range 
      of the components is:
     {ul
     {- L* is the lightness in the range [0.] to [100.]}
     {- C* represents chroma, in the range [0.] to 
        [181.02], but less in practice.}
     {- h represents hue in degrees in the range [0.] to [2pi].}} *)

  val of_lch_ab : lch_ab -> color
  (** [of_lch_ab c] is the L*C*h{_ab} color [c] as a [Gg] color. *)

  val to_lch_ab : color -> lch_ab
  (** [to_lch_ab c] is the [Gg] color [c] as a L*C*h{_ab}. *)

  (** {1 Color spaces} *)

  type space = [ 
    | `XYZ | `Lab | `Luv | `YCbr | `Yxy | `RGB | `Gray | `HSV | `HLS 
    | `CMYK | `CMY | `CLR2 | `CLR3 | `CLR4 | `CLR5 | `CLR6 | `CLR7 
    | `CLR8 | `CLR9 | `CLRA | `CLRB | `CLRC | `CLRD | `CLRE | `CLRF ]
  (** The type for color spaces. These correspond to the ICC v4 supported 
      color space, see the
      {{:http://www.color.org/icc_specs2.xalter}specification},
      section 7.2.6. *) 

  val space_dim : space -> int
  (** [space_dim s] is the dimension of the color space [s]. *)

  val pp_space : Format.formatter -> space -> unit 
  (** [pp_space s] prints a textual representation of [s] on [ppf]. *)

  (** {1:colorprofiles Color profiles} *)

  type profile 
  (** The type for {{:http://www.color.org/}ICC} color profiles. A
      color profile can describe the characteristics of a color space,
      an input or output device and provide a mapping to a profile
      connection space (PCS), which is either CIE L*a*b* or XYZ with a
      D50 white point.  For more information about ICC profile consult
      the {{:http://www.color.org/faqs.xalter}ICC FAQ} and the
      {{:http://color.org/icc_specs2.xalter}ICC v4 specification}.

      This module defines only a profile for the color space of 
      {!color} and a grayscale color space. *)

  val profile_of_icc : string -> profile option
  (** [profile_of_icc s] is a profile from the ICC profile byte 
      stream [s]. [None] is returned if [s] doesn't seem to be a ICC profile. 

      {b Note} A profile value is returned if a color space can be 
      extracted, it doesn't guarantee a correct ICC profile byte stream. *)

  val profile_to_icc : profile -> string 
  (** [profile_to_icc p] is [p]'s ICC profile byte stream. *)
  
  val profile_space : profile -> space
  (** [profile_space p] is [p]'s color space. *)

  val profile_dim : profile -> int
  (** [profile_space p] is [space_dim (profile_space d)]. *)

  val p_gray_l : profile 
  (** [p_gray_l] is a linear gray color profile *)

  val p_rgb_l : profile
  (** [p_rgb_l] is the color profile of {{!t}color} values. *)
end

(** {1:raster Raster data} *)

type raster
(** The type for raster data. *)

(** Raster data.

    {b WARNING.} This interface is subject to change in the future.

    Raster data organizes data samples of any dimension in discrete
    1D, 2D (images) or 3D space.

    A sample has a {{!type:sample_semantics}{e semantics}} that defines its
    dimension and the meaning of its {e components}. For example a 4D
    sample could represent a linear sRGBA sample. Samples are stored
    in a {{!type:buffer}linear buffer} of {e scalars} of a given
    {{!type:scalar_type}type}. A sample can use one scalar per component,
    can be packed in a single scalar or may have no direct obvious
    relationship to buffer scalars (compressed data). A
    {{!type:sample_format}sample format} defines the semantics and
    scalar storage of a sample.

    A {{!t}{e raster data}} value is a collection of samples indexed by width, 
    height and depth (i.e. x, y, z) stored in a buffer. It defines
    the sample data, the extents of the index and the sample format.

    {b Spatial convention.} If the sample index has to be interpreted
    spatially. It must be interpreted relative to the origin of a
    right-handed coordinate system. This means that the first sample,
    indexed by [(0, 0, 0)] is the bottom-left backmost sample
    (bottom-left sample for an image). *) 
module Raster : sig

  (** {1:scalars Scalar types and buffers} *)

  type scalar_type = 
    [ `Int8 | `Int16 | `Int32 | `Int64 
    | `UInt8 | `UInt16 | `UInt32 | `UInt64
    | `Float16 | `Float32 | `Float64 ]
  (** The type for scalar types. *)

  val scalar_type_byte_count : scalar_type -> int 
  (** [scalar_type_byte_count st] is the number of bytes used by a scalar
      of type [st]. *)

  val pp_scalar_type : Format.formatter -> scalar_type -> unit 
  (** [pp_scalar_type ppf st] prints a textual representation of [st]
      on [ppf]. *)

  type ('a, 'b) bigarray = ('a, 'b, Bigarray.c_layout) Bigarray.Array1.t 
  (** The type for big arrays. *)

  type buffer = [ 
  | `S_UInt8 of string 
  | `A_Float64 of float array
  | `B_Int8 of (int, Bigarray.int8_signed_elt) bigarray
  | `B_Int16 of (int, Bigarray.int16_signed_elt) bigarray
  | `B_Int32 of (int32, Bigarray.int32_elt) bigarray
  | `B_Int64 of (int64, Bigarray.int64_elt) bigarray
  | `B_UInt8 of (int, Bigarray.int8_unsigned_elt) bigarray
  | `B_UInt16 of (int, Bigarray.int16_unsigned_elt) bigarray
  | `B_UInt32 of (int32, Bigarray.int32_elt) bigarray
  | `B_UInt64 of (int64, Bigarray.int64_elt) bigarray
  | `B_Float16 of (int, Bigarray.int16_unsigned_elt) bigarray
  | `B_Float32 of (float, Bigarray.float32_elt) bigarray
  | `B_Float64 of (float, Bigarray.float64_elt) bigarray ]
  (** The type for linear buffer of scalars. *)

  val buffer_scalar_type : buffer -> scalar_type 
  (** [buffer_scalar_type b] is [b]'s buffer scalar type. *)

(*  
  val buffer_length : buffer -> int 
  (** [buffer_length b] is [b]'s buffer scalar length. *)
*)

  val pp_buffer : Format.formatter -> buffer -> unit
  (** [pp_buffer b] prints a textual representation of [b] on 
      [ppf]. Does not print the buffer's data. *)

  (** {1:semantics Sample semantics} *)

  type sample_semantics = 
    [ `Other of string * int
    | `Color of Color.profile * bool]
  (** The type for sample semantics. 
      {ul 
      {- [`Color (p, alpha)] is for color samples from the
         color profile [p]. [alpha] indicates if there's an alpha
         component on the {e right} of the color components.}
      {- [`Other(label, dim)] is for samples of [dim] dimension 
      identified by [label].}} *)
  
  val rgb_l : sample_semantics 
  (** [rgb_l] is for linear RGB samples from the {!Color.p_rgb_l}
      profile. *)
  
  val rgba_l : sample_semantics
  (** [rgba_l] is for linear RGB samples from the  {!Color.p_rgb_l} 
      profile with an alpha component. *)

  val gray_l : sample_semantics
  (** [gray_l] is for linear Gray samples from the {!Color.p_gray_l} 
      profile. *)

  val graya_l : sample_semantics
  (** [graya_l] is for linear Gray samples from the {!Color.p_gray_l} 
      luminance with an alpha component. *)

  val pp_sample_semantics : Format.formatter -> sample_semantics -> unit 
  (** [pp_sample_semantics ppf sem] prints a textual representation of [sem] 
      on [ppf]. *)

  (** {1:samples Sample format} *)

  type sample_pack =
    [ `PU8888 | `FourCC of string * scalar_type option
    | `Other of string * scalar_type option ]
  (** The type for sample packs. A sample pack describes storage for samples 
      that do not use one scalar per component. 
      {ul 
      {- [`PU8888]. An arbitrary 4D sample X, Y, Z, W with unsigned
         8 bits components packed in a single [`Uint32] scalar 
         as [0xXXYYZZWWl].}
      {- [`FourCC(code, restrict)]. A sample is stored according to the
         format specified by the FourCC [code], a string of length 4.
         If [restrict] is specified the pack can only be used with the
         corresponding scalar type. For example [`FourCC("DXT5", Some
         `Uint64)] can be used to specify a buffer of DXT5 compressed
         data. [`FourCC] can also be used to describe the numerous YUV
         packed pixel formats.}
      {- [`Other(label, restrict)]. A sample is stored in some other
         packing scheme identified by [label], [restrict] has the same
         meaning as in [`FourCC].}}
  *)

  val pp_sample_pack : Format.formatter -> sample_pack -> unit 
  (** [pp_sample_pack ppf pack] prints a textual representation of [pack]
      on [ppf]. *)

  type sample_format
  (** The type for sample formats. *)
  
  val sample_format_v : ?pack:sample_pack -> sample_semantics -> 
    scalar_type -> sample_format 
  (** [sample_format_v pack sem st] is a sample format with semantics 
      [sem] and scalar type [st]. If [pack] is absent one scalar of type [st] 
      per sample component is used. If present, see {!type:sample_pack}.

     @raise Invalid_argument if [pack] is incompatible with [st], 
     see {!type:sample_pack} or if a [pack] [`FourCC] code is not made of 
     4 bytes. *)

  val sf_semantics : sample_format -> sample_semantics 
  (** [sf_semantics sf] is [sf]'s semantics. *)

  val sf_scalar_type : sample_format -> scalar_type 
  (** [sf_scalar_type sf] is [sf]'s buffer scalar type *)

  val sf_pack : sample_format -> sample_pack option
  (** [sf_pack sf] is [sf]'s sample pack, if any. *)

  val sf_dim : sample_format -> int
  (** [sf_dim sf] is [sf]'s sample dimension. *)

  val sf_scalar_count : ?first:int -> ?w_skip:int -> ?h_skip:int -> 
    w:int -> ?h:int -> ?d:int -> sample_format -> int
  (** [sf_scalar_count first w_skip h_skip w h d sf] is the minimal 
      number of scalars needed to hold a raster data with the corresponding 
      parameters, see {!v} for their description. 

      @raise Invalid_argument if [sf] is packed. *)

  val pp_sample_format : Format.formatter -> sample_format -> unit 
  (** [pp_sample_format ppf sf] prints a textual representation of [sf]
      on [ppf].*)

  (** {1:raster Raster data} *)
    
  type t = raster
  (** The type for raster data. *)

  (** {2 Constructor, accessors} *)

  val v : ?res:v3 -> ?first:int -> ?w_skip:int -> 
  ?h_skip:int -> w:int -> ?h:int -> ?d:int -> sample_format -> buffer -> t
  (** [v res first w_skip h_skip w h d sf buf] is raster data with 
      sample format [sf] and buffer [b].
      {ul
      {- [w], [h], [d], specify the index width, height and depth, in 
         number of {e samples}. [h] and [d] default to [1].}
      {- [first], {e buffer scalar} index where the data of the first sample
         is stored.}
      {- [w_skip], number of {e buffer scalars} to skip between two 
         consecutive lines, defaults to [0].} 
      {- [h_skip], number of {e buffer scalars} to skip between two 
         consecutive planes, defaults to [0].}
      {- [res], is an optional sample resolution specification in 
         samples per meters.}}
     For certain sample formats [first], [w_skip] and [h_skip] can be used 
     to specify subspaces in the collection of samples, see {!sub}. 

     The function {!pitches} can be used to easily compute the buffer
     scalar index where a sample [(x,y,z)] starts.

  @raise Invalid_argument if [w], [h] or [d] is not positive or 
  if [first], [w_skip] or [h_skip] is negative. Or if the scalar type of 
  [sf] doesn't match [(Raster.buffer_scalar_type b)].
*)

  val res : t -> v3 option
  (** [res r] is [r]'s resolution in sample per meters, if any. *)
  
  val first : t -> int
  (** [first r] is the {e buffer scalar} index where the first sample 
      is stored. *)
  
  val w_skip : t -> int
  (** [w_skip r] is the number of {e buffer scalars} to skip between 
      two consecutive lines. *)

  val h_skip : t -> int
  (** [f_h_skip r] is the number of {e buffer scalars} to skip 
      between two consecutive planes. *)

  val w : t -> int
  (** [w r] is the index width in number of {e samples}. *)

  val h : t -> int
  (** [h r] is the index height in number of {e samples}. *)

  val d : t -> int
  (** [d r] is the index depth in number of {e samples}. *)

  val sample_format : t -> sample_format
  (** [f_sample_format r] is [r]'s sample format. *)

  val buffer : t -> buffer
  (** [buffer r] is [r]'s format. *)

  (** {2 Functions} *)

  val dim : t -> int
  (** [dim r] is [r]'s index dimension from 1 to 3. *)

  val size2 : t -> size2
  (** [size2 r] is [r]'s index width and height as floats. *)

  val size3 : t -> size3
  (** [size3 r] is [r]'s index width, height and depth as floats. *)

  val sub : ?x:int -> ?y:int -> ?z:int -> ?w:int -> ?h:int -> ?d:int -> 
    t -> t
  (** [sub x y z w h d r] is a raster corresponding to a 
      subset of the index of [r]. Both [r] and the resulting raster 
      share the same buffer.
      {ul
       {- [x], [y], [z], new sample origin of the raster data, 
          defaults to [(0, 0, 0)].}
       {- [w], [h], [d], new size of the index, defaults to [r]'s 
          sizes minus the new sample origin.}}
     @raise Invalid_argument, if the sample format of [r] is 
     packed, if the origin is out of bounds or if new size is larger than 
     [r]'s size. *)

  val pitches : t -> int * int * int 
  (** [pitches r] is [(x_pitch, y_pitch, z_pitch)] where 
      {ul
       {- [x_pitch] is the number of buffer scalars from sample to sample.}
       {- [y_pitch] is the number of buffer scalars from line to line.} 
       {- [z_pitch] is the number of buffer scalars from plane to plane.}}
      The buffer index where the sample [(x,y,z)] starts is given by: 
{[
(Raster.first r) + z * z_pitch + y * y_pitch + x * x_pitch
]}
  
      @raise Invalid_argument if the sample format of [r] is
      packed.
  *)

  (** {2 Predicates and comparisons} *)

  val equal : t -> t -> bool
  (** [equal r r'] is [r = r']. *)

  val compare : t -> t -> int
  (** [compare r r'] is [Pervasives.compare r r']. *)

  (** {2 Printers} *)

  val to_string : t -> string 
  (** [to_string r] is a textual representation of [r]. Doesn't
      print the buffer samples. *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf t] prints a textual represenation of [t] on [ppf]. Doesn't
      print the buffer samples. *)
end

(** {1:basics Basics} 

    [Gg] is designed to be opened in your module. This defines only
    types and modules in your scope, no values. Thus to use [Gg] start
    with : {[open Gg]} 


    In the toplevel, if you installed [Gg] with ocamlfind, requiring
    [Gg]:
{[
> #require "gg";;
]}
    automatically opens [Gg] and installs printers for the types. 

    {2:conventions Conventions}

    Most types and their functions are defined with the following
    conventions. The type is first defined in [Gg], like {!v2} for 2D
    vectors, a module for it follows. The name of the module is
    the type name capitalized, e.g. {!V2} for 2D vectors and it has 
    the following definitions:
    {ul
    {- a type [t] equal to the original toplevel type ({!V2.t}).}    
    {- [dim], an [int] value that indicates the dimensionality 
       of the type ({!V2.dim}).}
    {- [v], a constructor for the type ({!V2.v}).}
    {- [to_string] and [pp] to convert values to a textual 
       representation for debugging purposes and toplevel interaction
       ({!V2.to_string}, {!V2.pp}).}
    {- [equal] and [compare] the standard functions that make a module 
       a good functor argument ({!V2.equal}, {!V2.compare}).}
    {- [equal_f] and [compare_f] which compare
       like [equal] and [compare] but allow to use a client provided
       function to compare floats ({!V2.equal_f}, {!V2.compare_f}).}
    {- [ltr] and [tr] to apply linear and affine transforms
       on the type ({!V2.ltr}, {!V2.tr}).}
    {- Other accessors (e.g. {!V2.x}), constants (e.g. {!V2.zero}),
       functions (e.g. {!V2.dot}) and predicates (e.g. {!V2.exists})
       specific to the type.}
    {- Modules that represent the same object but for different
       dimensions, like {!V2}, {!V3}, {!V4} for vectors,  usually 
       share a common signature. This common
       signature is collected in a module type defined in [Gg], 
       this signature is {!V} for vectors.}}

    Some types are defined as simple abreviations. For example the
    type {!p2} for 2D points is equal to {!v2}. These types also have
    a module whose name is the type name capitalized, {!P2} in our
    example. However this module only provides alternate constructors,
    constants and accessors and the extended functionality specific to the
    type. You should fallback on the module of the abreviated type
    ({!V2} in our example) for other operations. The aim of these
    types is to make your code and signatures semantically clearer
    without the burden of explicit conversions.

    Finally there are some types and modules like {!Color} whose structure
    is different because they provide specific functionality. 

    Here are a few other conventions : 
    {ul
    {- Numbers in names indicate dimensionality when ambiguity can arise. 
       For example {!M4.scale3} indicates scale in 3D space while {!M4.scale}
       scale in 4D space.}
    {- Most functions take the value they act upon first.
       But exceptions abound, to match OCaml conventions, to have your 
       curry or to match mathematical notation (e.g. {!V2.tr}).}
    {- Conversion functions follow the [of_] conventions. Thus to convert
       a value of type [t'] to a value of type [t] look for the function 
       named [T.of_t'].}}

    To conclude note that it is sometimes hard to find the right place
    for a function. If you cannot find a function look into each of
    the modules of the types you want to act upon.

    {2:mathconv Mathematical conventions}
    {ul
    {- In 3D space we assume a
    {{:http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html}
    right-handed} coordinate system.}
    {- Angles are always given in radians (except in 
      {{!Float.rad_of_deg}this} function...).} 
    {- In 2D space positive angles determine counter clockwise rotations.}
    {- In 3D space positive angles determine rotations directed according to 
       the right hand rule.}}

    {2:colornote Note on colors} 

    Values of type {!color} are in a {e linear} sRGB space as this is
    the space to work in if you want to process colors correctly (e.g.
    for blending). The constructor {!Color.v_srgb} takes its parameters
    from a {e non-linear} sRGB space and converts them to {e linear} 
    sRGB. 
{[
# let c = Color.v_srgb 0.5 0.5 0.5 1.0;;
- : Gg.color = (0.214041 0.214041 0.214041 1)
]}
    This is the constructor you are likely to use when you specify color
    constants (e.g. to specify a color value matching a CSS color). 
    If you need an sRGB color back from a {!color} value use {!Color.to_srgb}: 
{[
# Color.to_srgba c;;
- : Gg.Color.srgba = (0.5 0.5 0.5 1)
]}

    {2:tipsremarks Remarks and Tips}
    {ul
    {- Everything is tail-recursive.}
    {- [to_string] functions are not thread-safe. Thread-safety can
       be achieved with [pp] functions.} 
    {- Do not rely on the output of printer functions, they are
       subject to change. The only exception is {!Float}'s module
       {{!Float.printers}printers} that output a lossless textual 
       representation of floats.  While the actual format is subject to 
       change it will remain compatible with [float_of_string].}
    {- All modules can be directly given as arguments to [Set.Make]
       and [Map.Make]. However this will use [Pervasives.compare] and
       thus binary comparison between floats. Depending on the intended
       use this may be sensible or not. Comparisons with alternate functions 
       to compare floats can be defined by using the functions named 
       [compare_f] (e.g. {!V2.compare_f}).  An alternate float comparison
       function is {!Float.compare_tol}
       that combines relative and absolute float comparison in a single
       test, see {!Float.equal_tol} for the details.}
    {- For performance reasons some functions of the {!Float} module 
       are undefined on certain arguments but do not raise [Invalid_argument]
       on those. As usual do not rely on the behaviour of functions on undefined
       arguments, these are subject to change.}}
*)

(*---------------------------------------------------------------------------
   Copyright (c) 2013 Daniel C. BÃ¼nzli
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
     
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   3. Neither the name of the Daniel C. BÃ¼nzli nor the names of
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ---------------------------------------------------------------------------*)
