(*---------------------------------------------------------------------------
   Copyright (c) %%COPYRIGHT%%. All rights reserved.
   Distributed under a BSD license, see license at the end of the file.
   %%PROJECTNAME%% version %%VERSION%%
  --------------------------------------------------------------------------*)

(** Basic types for computer graphics.  

    [Gg] defines types and functions for {{!Float}floats},
    {{!vectors}vectors}, {{!points}points},
    {{!matrices}matrices}, {{!quaternions}quaternions}, {{!sizes}sizes},
    {{!aboxes}axis aligned boxes}, {{!colors}colors}, 
    {{!Color.colorprofiles}color profiles} and {{!raster}raster data}.

    Consult the {{!basics}basics}. Open the module to use it, this
    defines only modules and types in your scope. 

    {e Version %%VERSION%% - %%EMAIL%% } *)

(**    {1:float Floats} *)

(** Floating point number utilities.  

    This module defines a few useful {{!constants}constants},
    {{!functions}functions}, {{!comparisons}predicates and
    comparisons} on floating point numbers. The {{!printers}printers}
    output a lossless textual representation of floats.

    {{!floatrecall}Quick recall} on OCaml's floating
    point representation. *)
module Float : sig

  type t = float
  (** The type for floating point numbers. *)

  (** {1:constants Constants} *)

  val e : float 
  (** The constant {{:http://mathworld.wolfram.com/e.html}e}. *)
 
  val pi : float
  (** The constant {{:http://mathworld.wolfram.com/Pi.html}pi}. *)

  val pi_div_2 : float
  (** [pi /. 2]. *)

  val pi_div_4 : float
  (** [pi /. 4]. *)

  val inv_pi : float
  (** [1 /. pi]. *)

  val max_sub_float : float
  (** The greatest positive subnormal floating point number. *)

  val min_sub_float : float 
  (** The smallest positive subnormal floating point number. *)

  val max_frac_float : float 
  (** The greatest positive floating point number with a fractional
      part (the [float] before 2{^52}). Any number outside
      \[[-max_frac_float;max_frac_float]\] is an integer. *)

  val max_int_arith : float 
  (** The greatest positive floating point number (2{^53}) such that
      any {e integer} in the range
      \[[-max_int_arith;max_int_arith]\] is represented exactly.
      Integer arithmetic can be performed exactly in this interval. *)

  (** {1:functions Functions} 
      
      {b Note.} If applicable, a function taking NaNs returns a NaN 
      unless otherwise specified. *)

  val deg_of_rad : float -> float
  (** [deg_of_rad r] is [r] 
     {{:http://mathworld.wolfram.com/Radian.html}radians} in 
     {{:http://mathworld.wolfram.com/Degree.html}degrees}. *)

  val rad_of_deg : float -> float
  (** [rad_of_deg d] is [d]
     {{:http://mathworld.wolfram.com/Degree.html}degrees} in
     {{:http://mathworld.wolfram.com/Radian.html}radians}. *) 

  val random : ?min:float -> len:float -> unit -> float
 (** [random min len ()] is a random float in the interval
      \[[min;min+len]\] ([min] defaults to 0.). Uses the standard
      library's default [Random] state for the generation.

     {b Warning.} The float generated by a given state may
     change in future versions of the library. *)

  val srandom : ?min:float -> len:float -> Random.State.t ->  unit -> float 
  (** [srandom min len state ()] is like {!random} but uses [state]
      for the generation. 
      
      {b Warning.} The float generated by a given [state] may
      change in future versions of the library. *)

  val mix : float -> float -> float -> float
  (** [mix x y t] is the linear interpolation [x +. t *. (y -. x)]. *)

  val step : float -> float -> float 
  (** [step edge x] is [0.] if [x < edge] and [1.] otherwise. The
      result is undefined on NaNs. *)

  val smooth_step : float -> float -> float -> float 
  (** [smooth_step e0 e1 x] is [0.] if [x <= e0], [1.] if [x >= e1]
      and cubic hermite interpolation between 0. and 1. otherwise. The
      result is undefined on NaNs. *)

  val fmax : float -> float -> float 
  (** [fmax x y] is [y] if [x < y] and [x] otherwise. If [x] or [y] is
      NaN returns the other argument. If both are NaNs returns NaN. *)

  val fmin : float -> float -> float 
  (** [fmin x y] is [x] if [x < y] and [y] otherwise. If [x] or [y] is
      NaN returns the other argument. If both are NaNs returns NaN. *)

  val clamp : min:float -> max:float -> float -> float 
  (** [clamp min max x] is [min] if [x < min], [max] if [x > max] and
      [x] otherwise. The result is undefined on NaNs and if [min >
      max]. *)

  val remap : min:float -> max:float -> min':float -> max':float -> float -> 
    float
  (** [remap min max min' max' x] applies to [x] the
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine
      transformation} mapping the interval \[[min;max]\] to
      \[[min';max']\]. The result is undefined if [min > max] or [min'
      > max']. *)

  val round : float -> float
  (** [round x] is the integer nearest to [x]. Ties are rounded
      towards positive infinity. If [x] is an infinity, returns [x]. 

      {b Note.} If the absolute magnitude of [x] is an integer strictly 
      greater than {!max_frac_float}, [round x = x] may be [false].  *)

  val int_of_round : float -> int
  (** [int_of_round x] is [truncate (round v)]. The result is 
      undefined on NaNs and infinities. *)

  val round_dfrac : int -> float -> float 
  (** [round_dfrac d x] rounds [x] to the [d]th {e decimal} fractional
      digit. Ties are rounded towards positive infinity.  If [x] is an
      infinity, returns [x]. The result is only defined for [0 <= d <=
      16]. *)

  val round_dsig : int -> float -> float 
  (** [round_dsig d x] rounds the normalized {e decimal} significand
      of [x] to the [d]th decimal fractional digit. Ties are rounded
      towards positive infinity. The result is NaN on infinities.  The
      result only defined for [0 <= d <= 16].

      {b Warning.} The current implementation overflows on large [x]
      and [d]. *)

  val chop : eps:float -> float -> float
  (**  [chop eps x] is [round x] if [abs_float (x -. round x) < eps] and [x] 
       otherwise. The result is undefined if [eps] is NaN. *)

  val chop_z : eps:float -> float -> float 
  (** [chop_z eps x] is [0.] if [abs_float x < eps] and [x] otherwise. 
      [eps] defaults to [1e-10]. The result is undefined if [eps] is NaN. *)

  val sign : float -> float 
  (** [sign x] is [1.] if [x > 0.], [0.] if [x = 0.], [-1.] if [x < 0.] *)

  val sign_bit : float -> bool
  (** [sign_bit x] is [true] iff the sign bit is set in [x]. *)
  
  val copy_sign : float -> float -> float 
  (** [copy_sign x s] is [x] with the sign of [s]. *)

  val succ : float -> float 
  (** [succ x] is the floating point value just after [x] towards positive
      infinity. Returns in particular : 
      {ul 
      {- NaN on NaNs.}
      {- [infinity] on [infinity].}
      {- [-max_float] on [neg_infinity].}
      {- [min_sub_float] on [0.] {b or} [-0.].}} *)

  val pred : float -> float 
  (** [pred x] is [-. succ (-.x)], i.e. the floating point value before 
      [x] towards negative infinity. *)

  val nan : int -> float 
  (** [nan payload] is a NaN whose 51 lower significand bits are
      defined by the 51 lower (or less, as [int] allows) bits of
      [payload]. *)

  val nan_payload : float -> int
  (** [nan_payload x] is the 51 lower significand bits (or less, as
      [int] allows) of the NaN [x].  

      {b Raises} [Invalid_argument] if [x] is not a NaN. *)

  (** {1:comparisons Predicates and comparisons} *)

  val is_nan : float -> bool 
  (** [is_nan x] is [true] iff [x] is a NaN. *)

  val is_inf : float -> bool 
  (** [is_inf x] is [true] iff [x] is [infinity] or [neg_infinity]. *)

  val is_int : float -> bool
  (** [is_int x] is [true] iff [x] is an integer. *)

  val equal : float -> float -> bool
  (** [equal x y] is [x = y]. *)

  val equal_tol : eps:float -> float -> float -> bool 
  (** [equal_tol eps x y] is [true] iff |[x - y]| <= [eps] * max
      (1,|[x]|,|[y]|). On special values the function behaves like
      [compare x y = 0].  

      The condition turns into an absolute tolerance test for small
      magnitudes and a relative tolerance test for large magnitudes. *)

  val compare : float -> float -> int
  (** [compare x y] is [Pervasives.compare x y]. *)

  val compare_tol : eps:float -> float -> float -> int
  (** [compare_tol ~eps x y] is [0] iff [equal_tol ~eps x y] is [true]
      and [Pervasives.compare x y] otherwise. *)

  (** {1:printers Printers} *)
  
  val to_string : float -> string
  (** [to_string x] is a lossless textual representation of [x].
      {ul 
      {- Normals are represented by ["[-]0x1.<f>p<e>"] where
         [<f>] is the significand bits in hexadecimal and [<e>] the 
         unbiased exponent in decimal.}
      {- Subnormals are represented by ["[-]0x0.<f>p-1022"] where 
         [<f>] is the significand bits in hexadecimal.}
      {- NaNs are represented by ["[-]nan(0x<p>)"] where [<p>] is the payload
         in hexadecimal.}
      {- Infinities and zeroes are represented by ["[-]inf"] and ["[-]0."].}}

      This format should be compatible with recent implementations of 
      {{:http://www.opengroup.org/onlinepubs/000095399/functions/strtod.html}
      strtod} and hence with [float_of_string] (but negative NaNs seem to 
      be problematic to get back) . *)

  val print : Format.formatter -> float -> unit
  (** [print ppf x] prints [x] on [ppf] according to the lossless
      representation of {!to_string}. *) 

  (** {1:floatrecall Quick recall on OCaml's [float]s} 

     An OCaml [float] is an
     {{:http://ieeexplore.ieee.org/servlet/opac?punumber=4610933}IEEE-754}
     64 bit double precision binary floating point number. The 64 bits
     are laid out as follows :
{v
+----------------+-----------------------+-------------------------+
| sign s (1 bit) | exponent e (11 bits)  | significand t (52 bits) |
+----------------+-----------------------+-------------------------+
               63|62                   52|51                      0|
v}
   
    The value represented depends on s, e and t :
{v
sign   exponent       significand   value represented           meaning
-------------------------------------------------------------------------
s      0              0             -1^s * 0                    zero
s      0              t <> 0        -1^s * 0.t * 2^-1022        subnormal
s      0 < e < 2047   f             -1^s * 1.t * 2^(e - 1023)   normal
s      2047           0             -1^s * infinity             infinity
s      2047           t <> 0        NaN                         not a number
v}

     There are two zeros, a positive and a negative one but both are
     deemed equal by [=] and [Pervasives.compare]. A NaN is never equal
     (=) to {e itself} or to another NaN however [Pervasives.compare]
     asserts any NaN to be equal to itself and to any other NaN.

     The bit layout of a [float] can be converted to an [int64] and
     back using [Int64.bits_of_float] and [Int64.float_of_bits].
     
     The bit 51 of a NaN is used to distinguish between quiet (bit set)
     and signaling NaNs (bit cleared); the remaining 51 lower bits of
     the significand are the NaN's {e payload} which can be used to
     store diagnostic information. These features don't seem to used in
     OCaml.
     
     The significand of a floating point number is made of 53 binary
     digits (don't forget the implicit digit), this corresponds to 
     log{_10}(2{^53}) ~ 16 {e decimal} digits.
     
     Only [float] values in the interval \][-2]{^52};2{^52}\[ may have
     a fractional part. {!Float.max_frac_float} is the greatest
     positive [float] with a fractional part.
     
     Any integer value in the interval \[[-2]{^53};2{^53}\] can be
     represented exactly by a [float] value.  {e Integer} arithmetic
     performed in this interval is exact.  {!Float.max_int_arith} is
     2{^53}. *)

end

(** The following type are defined so that they can be used
    in vector modules. The matrix modules are {{!matrices}here}. *)

type m2
(** The type for 2x2 matrices. *)

type m3
(** The type for 3x3 matrices. *)

type m4
(** The type for 4x4 matrices. *)

(** {1:vectors Vectors} 

    An n-dimensional {e vector} [v] is a sequence of n, zero indexed,
    floating point {e components}. We write [v]{_i} the ith component
    of a vector. *)

type v2
(** The type for 2D vectors. *)

type v3
(** The type for 3D vectors. *)

type v4
(** The type for 4D vectors. *)

(** Implemented by all vector types. {1:top  }*)
module type V = sig
  type t
  (** The type for vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!t}. *)

  type m
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val comp : int -> t -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val zero : t
  (** [zero] is the neutral element for {!add}. *)

  val infinity : t
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : t
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> t
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  (** {1:functions Functions} *)

  val neg : t -> t
  (** [neg v] is the inverse vector [-v]. *)

  val add : t -> t -> t
  (** [add u v] is the vector addition [u + v]. *)

  val sub : t -> t -> t
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : t -> t -> t
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : t -> t -> t
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> t -> t
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : t -> t
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : t -> t -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : t -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : t -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : t -> t
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : t -> t 
  (** [homogene v] is the vector [v/(coord (dim - 1) v)]. *)

  val mix : t -> t -> float -> t
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m -> t -> t
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  (** Overridden [Pervasives] operators. *)
  module Ops : sig
    val ( + ) : t -> t -> t 
    (** See {!add}. *)

    val ( - ) : t -> t -> t
    (** See {!sub}. *)

    val ( * ) : float -> t -> t 
    (** See {!smul}. *)
  end

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> t -> t
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> t -> t
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> t -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> t -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> t -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  t -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> t -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> t -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : t -> t -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> t -> t -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : t -> string
  (** [to_string v] is a textual representation of [v]. *)

  val print : Format.formatter -> t -> unit
  (** [print ppf v] prints a textual representation of [v] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    t -> unit
  (** [print_f pp_comp ppf v] prints [v] like {!print} but uses 
      [pp_comp] to print floating point values. *)
end

module V2 : sig
  type t = v2
  (** The type for 2D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v2}. *)

  type m = m2
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations} of 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> v2
  (** [v x y] is the vector [(x y)]. *)

  val comp : int -> v2 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val x : v2 -> float 
  (** [x v] is the x component of [v].*)

  val y : v2 -> float 
  (** [y v] is the y component of [v].*)

  val ox : v2 
  (** [ox] is the unit vector [(1. 0.)]. *)

  val oy : v2 
  (** [oy] is the unit vector [(0. 1.)]. *)

  val zero : v2
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v2
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v2
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v2
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : float * float -> v2
  (** [of_tuple (x,y)] is [v x y]. *)

  val to_tuple : v2 -> float * float
  (** [of_tuple v] is [(x v, y v]). *)

  val of_v3 : v3 -> v2
  (** [of_v3 u] is [v (V3.x u) (V3.y u)]. *)

  val of_v4 : v4 -> v2
  (** [of_v4 u] is [v (V4.x u) (V4.y u)]. *)

  (** {1:functions Functions} *)

  val neg : v2 -> v2
  (** [neg v] is the inverse vector [-v]. *)

  val add : v2 -> v2 -> v2
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v2 -> v2 -> v2
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v2 -> v2 -> v2
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v2 -> v2 -> v2
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v2 -> v2
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v2 -> v2
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : v2 -> v2 -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v2 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v2 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v2 -> v2
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : v2 -> v2
  (** [homogene v] is the vector [v/v]{_y}. *)

  val polar_unit : float -> v2 
  (** [polar_unit a] is the unit vector whose angular
      {{:http://mathworld.wolfram.com/PolarCoordinates.html}polar
      coordinate} is given by [a]. *)

  val ortho : v2 -> v2 
  (** [ortho v] is [v] rotated by [pi] / 2. *)

  val mix : v2 -> v2 -> float -> v2
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m2 -> v2 -> v2
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  val tr : m3 -> v2 -> v2
  (** [tr m v] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 2D space of the {e vector} [v] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [v] is treated as a vector
      (infinite point, its last coordinate in homogenous space is 0) 
      and is thus translationally invariant. Use {!P2.tr} to
      transform finite points. *)

  (** Overridden [Pervasives] operators. *)
  module Ops : sig
    val ( + ) : v2 -> v2 -> v2 
    (** See {!add}. *)

    val ( - ) : v2 -> v2 -> v2
    (** See {!sub}. *)

    val ( * ) : float -> v2 -> v2 
    (** See {!smul}. *)
  end

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v2 -> v2
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v2 -> v2
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v2 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v2 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v2 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v2 -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> v2 -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v2 -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v2 -> v2 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v2 -> v2 -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v2 -> v2 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> v2 -> v2 -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : v2 -> string
  (** [to_string v] is a textual representation of [v]. *)

  val print : Format.formatter -> v2 -> unit
  (** [print ppf v] prints a textual representation of [v] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    v2 -> unit
  (** [print_f pp_comp ppf v] prints [v] like {!print} but uses 
      [pp_comp] to print floating point values. *)
end

module V3 : sig
  type t = v3
  (** The type for 3D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v3}. *)

  type m = m3
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> v3
  (** [v x y z] is the vector [(x y z)]. *)

  val comp : int -> v3 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val x : v3 -> float 
  (** [x v] is the x component of [v]. *)

  val y : v3 -> float 
  (** [y v] is the y component of [v]. *)

  val z : v3 -> float 
  (** [z v] is the z component of [v]. *)

  val ox : v3
  (** [ox] is the unit vector [(1. 0. 0.)]. *) 

  val oy : v3
  (** [oy] is the unit vector [(0. 1. 0.)]. *) 

  val oz : v3
  (** [oz] is the unit vector [(0. 0. 1.)]. *) 

  val zero : v3
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v3
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v3
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v3
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : (float * float * float) -> v3
  (** [of_tuple (x,y,z)] is [v x y z]. *)

  val to_tuple : v3 -> (float * float * float)
  (** [to_tuple v] is [(x v, y v, z v)]. *)

  val of_v2 : v2 -> z:float -> v3
  (** [of_v2 u z] is [v (V2.x u) (V2.y u) z]. *)

  val of_v4 : v4 -> v3
  (** [of_v4 u z] is [v (V4.x u) (V4.y u) (V4.z u)]. *)

  (** {1:functions Functions} *)

  val neg : v3 -> v3
  (** [neg v] is the inverse vector [-v]. *)

  val add : v3 -> v3 -> v3
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v3 -> v3 -> v3
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v3 -> v3 -> v3
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v3 -> v3 -> v3
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v3 -> v3
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v3 -> v3
  (** [half v] is the half vector [smul 0.5 v]. *)

  val cross : v3 -> v3 -> v3
  (** [cross u v] is the 
      {{:http://mathworld.wolfram.com/CrossProduct.html}cross product} 
      [u x v]. *)

  val dot : v3 -> v3 -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v3 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v3 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v3 -> v3
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : v3 -> v3
  (** [homogene v] is the vector [v/v]{_z}. *)

  val sphere_unit : float -> float -> v3 
  (** [sphere_unit theta phi] is the unit vector whose azimuth
      {{:http://mathworld.wolfram.com/SphericalCoordinates.html}spherical
      coordinate} is [theta] and zenith is [phi]. *)

  val mix : v3 -> v3 -> float -> v3
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m3 -> v3 -> v3
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  val tr : m4 -> v3 -> v3
  (** [tr m v] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 3D space of the {e vector} [v] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [v] is treated as a vector
      (infinite point, its last coordinate in homogenous space is 0) 
      and is thus translationally invariant. Use {!P3.tr} to
      transform finite points. *)

  (** Overridden [Pervasives] operators. *)
  module Ops : sig
    val ( + ) : v3 -> v3 -> v3 
    (** See {!add}. *)

    val ( - ) : v3 -> v3 -> v3
    (** See {!sub}. *)

    val ( * ) : float -> v3 -> v3 
    (** See {!smul}. *)
  end

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v3 -> v3
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v3 -> v3
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v3 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v3 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v3 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v3 -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> v3 -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v3 -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v3 -> v3 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v3 -> v3 -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v3 -> v3 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> v3 -> v3 -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : v3 -> string
  (** [to_string v] is a textual representation of [v]. *)

  val print : Format.formatter -> v3 -> unit
  (** [print ppf v] prints a textual representation of [v] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    v3 -> unit
  (** [print_f pp_comp ppf v] prints [v] like {!print} but uses 
      [pp_comp] to print floating point values. *)
end

module V4 : sig
  type t = v4
  (** The type for 4D vectors. *)

  val dim : int
  (** [dim] is the dimension of vectors of type {!v4}. *)

  type m = m4
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of 4D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float -> v4
  (** [v x y z w] is the vector [(x y z w)]. *)

  val comp : int -> v4 -> float
  (** [comp i v] is [v]{_[i]}, the [i]th component of [v].
      
      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val x : v4 -> float 
  (** [x v] is the x component of [v]. *)

  val y : v4 -> float 
  (** [y v] is the y component of [v]. *)

  val z : v4 -> float 
  (** [z v] is the z component of [v]. *)

  val w : v4 -> float 
  (** [z v] is the z component of [v]. *)

  val ox : v4
  (** [ox] is the unit vector [(1. 0. 0. 0.)]. *) 

  val oy : v4
  (** [oy] is the unit vector [(0. 1. 0. 0.)]. *) 

  val oz : v4
  (** [oz] is the unit vector [(0. 0. 1. 0.)]. *) 

  val ow : v4
  (** [ow] is the unit vector [(0. 0. 0. 1.)]. *) 

  val zero : v4
  (** [zero] is the neutral element for {!add}. *)

  val infinity : v4
  (** [infinity] is the vector whose components are [infinity]. *)

  val neg_infinity : v4
  (** [neg_infinity] is the vector whose components are [neg_infinity]. *)

  val basis : int -> v4
  (** [basis i] is the [i]th vector of an 
      {{:http://mathworld.wolfram.com/OrthonormalBasis.html}orthonormal basis} 
      of the vector space {!t} with inner product {!dot}. 

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val of_tuple : (float * float * float * float) -> v4
  (** [of_tuple (x,y,z,w)] is [v x y z w]. *)

  val to_tuple : v4 -> (float * float * float * float)
  (** [to_tuple v] is [(x v, y v, z v, w v)]. *)

  val of_v2 : v2 -> z:float -> w:float -> v4
  (** [of_v2 u z w] is [v (V2.x u) (V2.y u) z w]. *)

  val of_v3 : v3 -> w:float -> v4
  (** [of_v3 u w] is [v (V3.x u) (V3.y u) (V3.z u) w]. *)

  (** {1:functions Functions} *)

  val neg : v4 -> v4
  (** [neg v] is the inverse vector [-v]. *)

  val add : v4 -> v4 -> v4
  (** [add u v] is the vector addition [u + v]. *)

  val sub : v4 -> v4 -> v4
  (** [sub u v] is the vector subtraction [u - v]. *)

  val mul : v4 -> v4 -> v4
  (** [mul u v] is the component wise multiplication [u * v]. *)

  val div : v4 -> v4 -> v4
  (** [div u v] is the component wise division [u / v]. *)

  val smul : float -> v4 -> v4
  (** [smul s v] is the scalar multiplication [sv]. *)

  val half : v4 -> v4
  (** [half v] is the half vector [smul 0.5 v]. *)

  val dot : v4 -> v4 -> float
  (** [dot u v] is the 
      {{:http://mathworld.wolfram.com/DotProduct.html}dot product} [u.v]. *)

  val norm : v4 -> float
  (** [norm v] is the norm [|v| = sqrt v.v]. *)

  val norm2 : v4 -> float
  (** [norm2 v] is the squared norm [|v|]{^ 2} . *)

  val unit : v4 -> v4
  (** [unit v] is the unit vector [v/|v|]. *)

  val homogene : v4 -> v4
  (** [homogene v] is the vector [v/v]{_w}. *)

  val mix : v4 -> v4 -> float -> v4
  (** [mix u v t] is the linear interpolation [u + t(v - u)]. *)

  val ltr : m4 -> v4 -> v4
  (** [ltr m v] is the 
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transform} [mv]. *)

  (** Overridden [Pervasives] operators. *)
  module Ops : sig
    val ( + ) : v4 -> v4 -> v4 
    (** See {!add}. *)

    val ( - ) : v4 -> v4 -> v4
    (** See {!sub}. *)

    val ( * ) : float -> v4 -> v4 
    (** See {!smul}. *)
  end

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> v4 -> v4
  (** [map f v] is the component wise application of [f] to [v]. *)

  val mapi : (int -> float -> float) -> v4 -> v4
  (** [mapi f v] is like {!map} but the component index is also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> v4 -> 'a
  (** [fold f acc v] is [f (]...[(f (f acc v]{_0}[) v]{_1}[)]...[)]. *)

  val foldi : ('a -> int -> float -> 'a) -> 'a -> v4 -> 'a
  (** [foldi f acc v] is [f (]...[(f (f acc 0 v]{_0}[) 1 v]{_1}[)]...[)]. *)

  val iter : (float -> unit) -> v4 -> unit
  (** [iter f v] is [f v]{_0}[; f v]{_1}[;] ... *)

  val iteri : (int -> float -> unit) ->  v4 -> unit 
  (** [iteri f v] is [f 0 v]{_0}[; f 1 v]{_1}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> v4 -> bool 
  (** [for_all p v] is [p v]{_0}[ && p v]{_1}[ &&] ...*)

  val exists : (float -> bool) -> v4 -> bool 
  (** [exists p v] is [p v]{_0}[ || p v]{_1}[ ||] ...*)

  val equal : v4 -> v4 -> bool
  (** [equal u v] is [u = v]. *)

  val equal_f : (float -> float -> bool) -> v4 -> v4 -> bool 
  (** [equal_f eq u v] tests [u] and [v] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : v4 -> v4 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> v4 -> v4 -> int 
  (** [compare_f cmp u v] compares [u] and [v] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : v4 -> string
  (** [to_string v] is a textual representation of [v]. *)

  val print : Format.formatter -> v4 -> unit
  (** [print ppf v] prints a textual representation of [v] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    v4 -> unit
  (** [print_f pp_comp ppf v] prints [v] like {!print} but uses 
      [pp_comp] to print floating point values. *)
end

(** {1:points Points} 

    An n-dimensional {e point} [p] is a vector of the corresponding
    dimension. The components of the vector are the point's {e
    coordinates}.
*)

type p2 = v2
(** The type for 2D points. *)

type p3 = v3
(** The type for 3D points. *)

(** Implemented by all point types. {1:top  }*)
module type P = sig
  type t
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!t}. *)

  type mh
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val o : t
  (** [o] is the point whose coordinates are all zero. *)

  (** {1:functions Functions} *)  

  val mid : t -> t -> t
  (** [mid p q] is the mid point [p + (q-p)/2]. *)
      
  val tr : mh -> t -> t
  (** [tr m p] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} {!dim} space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point 
      (its last coordinate in homogenous space is 1). *)
end

module P2 : sig
  type t = p2
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!p2}. *)

  type mh = m3
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> p2
  (** [v x y] is the point [(x,y)]. *)

  val x : p2 -> float 
  (** [x p] is the x coordinate of [p].*)

  val y : p2 -> float 
  (** [y p] is the y coordinate of [p].*)

  val o : p2
  (** [o] is the point [(0,0)]. *)

  (** {1:functions Functions} *)
  
  val mid : p2 -> p2 -> p2
  (** [mid p q] is the mid point [p + (q-p)/2]. *)

  val tr : m3 -> p2 -> p2
  (** [tr m p] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 2D space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point 
      (its last coordinate in homogenous space is 1). Use {!V2.tr}
      to transform vectors (infinite points). *)
end

module P3 : sig
  type t = p3
  (** The type for points. *)

  val dim : int
  (** [dim] is the dimension of points of type {!p3}. *)

  type mh = m4
  (** The type for matrices representing linear transformations
      of {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      {e homogenous}} 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> p3
  (** [v x y z] is the point [(x,y,z)]. *)

  val x : p3 -> float 
  (** [x p] is the x coordinate of [p].*)

  val y : p3 -> float 
  (** [y p] is the y coordinate of [p].*)

  val z : p3 -> float 
  (** [y p] is the z coordinate of [p].*)

  val o : p3
  (** [o] is the point [(0,0,0)]. *)

  (** {1:functions Functions} *)
  
  val mid : p3 -> p3 -> p3
  (** [mid p q] is the mid point [p + (q-p)/2]. *)

  val tr : m4 -> p3 -> p3
  (** [tr m p] is the 
      {{:http://mathworld.wolfram.com/AffineTransformation.html}affine 
      transform} in {{:http://mathworld.wolfram.com/HomogeneousCoordinates.html}
      homogenous} 3D space of the {e point} [p] by [m].

      {b Note.} Since [m] is supposed to be affine the function
      ignores the last row of [m]. [p] is treated as a finite point 
      (its last coordinate in homogenous space is 1). Use {!V3.tr}
      to transform vectors (infinite points). *)
end

(** {1:matrices Matrices} 

    An {e m}x{e n} matrix [a] is an array of {e m} rows and {e n}
    columns of floating point {e elements}. We write [a]{_ij} the
    element of [a] located at the ith row and jth column.

    Matrix constructors specify matrix elements in
    {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order}
    so that matrix definitions look mathematically natural if you
    indent your code properly. However elements are {e stored} and {e
    iterated} over in
    {{:http://en.wikipedia.org/wiki/Column-major_order}column-major
    order}. *)

(** Implemented by all (square) matrix types.  {1:top  } *)
module type M = sig
  type t
  (** The type for matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v 
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val el : int -> int -> t -> float
  (** [el i j a] is the element [a]{_[ij]}. 

      {b Raises} [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)


  val row : int -> t -> v
  (** [row i a] is the [i]th row of [a].

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> t -> v
  (** [col j a] is the [j]th column of [a]. 

      {b Raises} [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : t
  (** [zero] is the neutral element for {!add}. *)

  val id : t
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  (** {1:functions Functions} *)

  val neg : t -> t
  (** [neg a] is the negated matrix [-a]. *)

  val add : t -> t -> t
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : t -> t -> t
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : t -> t -> t
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : t -> t -> t
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : t -> t -> t
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> t -> t
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : t -> t
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : t -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : t -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : t -> t
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> t -> t
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> t -> t
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> t -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> t -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> t -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  t -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> t -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> t -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : t -> t -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> t -> t -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : t -> string
  (** [to_string a] is a textual representation of [a]. *)

  val print : Format.formatter -> t -> unit
  (** [print ppf a] prints a textual representation of [a] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    t -> unit
  (** [print_f pp_e ppf a] prints [a] like {!print} but uses 
      [pp_e] to print floating point values. *)
end

module M2 : sig
  type t = m2
  (** The type for 2D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v2
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> 
          float -> float -> m2
  (** [v e00 e01 e10 e11] is a matrix whose components are 
      specified in     
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v2 -> v2 -> m2
  (** [of_rows r0 r1] is the matrix whose rows are [r0] and [r1]. *)

  val of_cols : v2 -> v2 -> m2
  (** [of_cols c0 c1] is the matrix whose columns are [c0] and [c1]. *)

  val el : int -> int -> m2 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      {b Raises} [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m2 -> v2
  (** [row i a] is the [i]th row of [a].

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m2 -> v2
  (** [col j a] is the [j]th column of [a]. 

      {b Raises} [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m2
  (** [zero] is the neutral element for {!add}. *)

  val id : m2
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m3 : m3 -> m2
  (** [of_m3 m] extracts the 2D linear part (top-left 2x2 matrix) of [m]. *)

  val of_m4 : m4 -> m2
  (** [of_m4 m] extracts the 2D linear part (top-left 2x2 matrix) of [m]. *)

  (** {1:functions Functions} *)

  val neg : m2 -> m2
  (** [neg a] is the negated matrix [-a]. *)

  val add : m2 -> m2 -> m2
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m2 -> m2 -> m2
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m2 -> m2 -> m2
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : m2 -> m2 -> m2
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m2 -> m2 -> m2
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m2 -> m2
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m2 -> m2
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m2 -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : m2 -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : m2 -> m2
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *) 

  val rot : float -> m2
  (** [rot theta] rotates 2D space around the origin by [theta]. *)

  val scale : v2 -> m2
  (** [scale s] scales 2D space in the [x] and [y] dimensions
      according to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m2 -> m2
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m2 -> m2
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m2 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m2 -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m2 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m2 -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> m2 -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m2 -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m2 -> m2 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m2 -> m2 -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m2 -> m2 -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m2 -> m2 -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : m2 -> string
  (** [to_string a] is a textual representation of [a]. *)

  val print : Format.formatter -> m2 -> unit
  (** [print ppf a] prints a textual representation of [a] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    m2 -> unit
  (** [print_f pp_e ppf a] prints [a] like {!print} but uses 
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m2 -> float
  val e01 : m2 -> float
  val e10 : m2 -> float
  val e11 : m2 -> float
end

module M3 : sig
  type t = m3
  (** The type for 3D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v3
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> 
          float -> float -> float -> 
	  float -> float -> float -> m3
  (** [v e00 e01 e02 e10 e11 e12 e20 e21 e22] is a matrix whose components 
      are specified in     
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v3 -> v3 -> v3 -> m3
  (** [of_rows r0 r1 r2] is the matrix whose rows are [r0], [r1] and [r2]. *)

  val of_cols : v3 -> v3 -> v3 -> m3
  (** [of_cols c0 c1 c2] is the matrix whose columns are [c0], [c1] and [c2]. *)

  val el : int -> int -> m3 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      {b Raises} [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m3 -> v3
  (** [row i a] is the [i]th row of [a].

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m3 -> v3
  (** [col j a] is the [j]th column of [a]. 

      {b Raises} [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m3
  (** [zero] is the neutral element for {!add}. *)

  val id : m3
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m2_v2 : m2 -> v2 -> m3
  (** [of_m2_v2 m v] is the matrix whose first two rows are
      those of [m],[v] side by side and the third is [0 0 1]. *)

  val of_m4 : m4 -> m3
  (** [of_m4 m] extracts the 3D linear part (top-left 3x3 matrix) of [m]. *)

  (** {1:functions Functions} *)

  val neg : m3 -> m3
  (** [neg a] is the negated matrix [-a]. *)

  val add : m3 -> m3 -> m3
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m3 -> m3 -> m3
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m3 -> m3 -> m3
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : m3 -> m3 -> m3
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m3 -> m3 -> m3
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m3 -> m3
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m3 -> m3
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m3 -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : m3 -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : m3 -> m3
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations2d 2D space transformations} *) 

  val move2 : v2 -> m3
  (** [move2 d] translates 2D space in the x and y dimensions according 
      to [d]. *)

  val rot2 : float -> m3
  (** See {!M2.rot}. *)

  val scale2 : v2 -> m3
  (** See {!M2.scale}. *)

  val rigid2 : move:v2 -> rot:float -> m3 
  (** [rigid2 move theta] is the rigid body transformation of 
      2D space that rotates by [theta] and then translates by [move]. *)

  val srigid2 : move:v2 -> rot:float -> scale:v2 -> m3 
  (** [srigid2 move theta scale] is like {!rigid2} but starts by
      scaling according to [scale]. *)
      
  (** {1:transformations3d 3D space transformations} *) 

  val rot_map : v3 -> v3 -> m3 
  (** [rot_map u v] rotates 3D space to map the {e unit} vector [u] on
      the {e unit} vector [v]. *)

  val rot_axis : v3 -> float -> m3
  (** [rot_axis v theta] rotates 3D space by [theta] around 
      the unit vector [v]. *)

  val rot_zyx : v3 -> m3 
  (** [rot_zyx r] rotates 3D space first by [V3.x r] around the
      x-axis, then by [V3.y r] around the y-axis and finally by [V3.z
      r] around the z-axis. *)

  val scale : v3 -> m3
  (** [scale s] scales 3D space in the [x], [y] and [z] dimensions
      according to [s]. *)
 
  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m3 -> m3
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m3 -> m3
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m3 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m3 -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m3 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m3 -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> m3 -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m3 -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m3 -> m3 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m3 -> m3 -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m3 -> m3 -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m3 -> m3 -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : m3 -> string
  (** [to_string a] is a textual representation of [a]. *)

  val print : Format.formatter -> m3 -> unit
  (** [print ppf a] prints a textual representation of [a] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    m3 -> unit
  (** [print_f pp_e ppf a] prints [a] like {!print} but uses 
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m3 -> float
  val e01 : m3 -> float
  val e02 : m3 -> float
  val e10 : m3 -> float
  val e11 : m3 -> float
  val e12 : m3 -> float
  val e20 : m3 -> float
  val e21 : m3 -> float
  val e22 : m3 -> float
end

module M4 : sig
  type t = m4
  (** The type for 4D square matrices. *)

  val dim : int
  (** [dim] is the dimension of rows and columns. *)

  type v = v4
  (** The type for rows and columns as vectors. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float ->
          float -> float -> float -> float ->
          float -> float -> float -> float ->
          float -> float -> float -> float -> m4
  (** [v e00 e01 e02 e03 e10 e11 e12 e13 e20 e21 e22 e23 e30 e31 e32 e33] 
      is a matrix whose components are specified in     
      {{:http://en.wikipedia.org/wiki/Row-major_order}row-major order} *)

  val of_rows : v4 -> v4 -> v4 -> v4 -> m4
  (** [of_rows r0 r1 r2 r3] is the matrix whose rows are [r0], [r1], [r2] and 
      [r3]. *)

  val of_cols : v4 -> v4 -> v4 -> v4 -> m4
  (** [of_cols c0 c1 c2 c3] is the matrix whose columns are [c0], [c1], [c2] 
      and [c3]. *)

  val el : int -> int -> m4 -> float
  (** [el i j a] is the element [a]{_[ij]}. See also the direct
      {{!accessors}element accessors}.

      {b Raises} [Invalid_argument] if [i] or [j] is not in \[[0;]{!dim}\[.*)

  val row : int -> m4 -> v
  (** [row i a] is the [i]th row of [a].

      {b Raises} [Invalid_argument] if [i] is not in \[[0;]{!dim}\[.*)

  val col : int -> m4 -> v
  (** [col j a] is the [j]th column of [a]. 

      {b Raises} [Invalid_argument] if [j] is not in \[[0;]{!dim}\[.*)

  val zero : m4
  (** [zero] is the neutral element for {!add}. *)

  val id : m4
  (** [id] is the identity matrix, the neutral element for {!mul}. *)

  val of_m3_v3 : m3 -> v3 -> m4 
  (** [of_m3_v3 m v] is the matrix whose first three rows are
      those of [m],[v] side by side and the fourth is [0 0 0 1]. *)

  (** {1:functions Functions} *)

  val neg : m4 -> m4
  (** [neg a] is the negated matrix [-a]. *)

  val add : m4 -> m4 -> m4
  (** [add a b] is the matrix addition [a + b]. *)

  val sub : m4 -> m4 -> m4
  (** [sub a b] is the matrix subtraction [a - b]. *)

  val mul : m4 -> m4 -> m4
  (** [mul a b] is the 
      {{:http://mathworld.wolfram.com/MatrixMultiplication.html}matrix 
      multiplication} [a * b]. *)

  val emul : m4 -> m4 -> m4
  (** [emul a b] is the element wise multiplication of [a] and [b]. *)

  val ediv : m4 -> m4 -> m4
  (** [ediv a b] is the element wise division of [a] and [b]. *)

  val smul : float -> m4 -> m4
  (** [smul s a] is [a]'s elements multiplied by the scalar [s]. *)

  val transpose : m4 -> m4
  (** [transpose a] is the 
      {{:http://mathworld.wolfram.com/Transpose.html}transpose} [a]{^ T}. *)

  val trace : m4 -> float
  (** [trace a] is the 
      {{:http://mathworld.wolfram.com/MatrixTrace.html}matrix trace} 
      [trace(a)]. *)

  val det : m4 -> float
  (** [det a] is the 
      {{:http://mathworld.wolfram.com/Determinant.html}determinant} [|a|]. *) 

  val inv : m4 -> m4
  (** [inv a] is the
      {{:http://mathworld.wolfram.com/MatrixInverse.html}inverse matrix}
      [a]{^ -1}. *)

  (** {1:transformations3d 3D space transformations} *)

  val move3 : v3 -> m4
  (** [move3 d] translates 3D space in the x, y and z dimensions according
      to [d]. *)

  val rot_map3 : v3 -> v3 -> m4
  (** See {!M3.rot_map}. *)

  val rot_axis3 : v3 -> float -> m4
  (** See {!M3.rot_axis}. *)

  val rot_zyx3 : v3 -> m4
  (** See {!M3.rot_zyx}. *)

  val scale3 : v3 -> m4
  (** See {!M3.scale}. *)

  val rigid3 : move:v3 -> rot:v3 * float -> m4
  (** [rigid3 move rot] is the rigid body transformation
      of 3D space that rotates by the axis/angle [rot]
      and then translates by [move]. *)

  val srigid3 : move:v3 -> rot:v3 * float -> scale:v3 -> m4
  (** [rigid3 scale move rot scale] is lik {!rigid3} but starts
      by scaling according to [scale]. *)

(*

(** Projection matrices assume a right-handed coordinate
    system with the eye at the origin looking down the z-axis. *)

  val ortho : left:float -> right:float -> bottom:float -> top:float 
  -> near:float -> far:float -> m4
  (** Orthographic projection.  Maps the axis aligned box with 
      corners [(left, bottom, -near)] and [(right, top, -far)] to 
      the cube with corner [(-1, -1, -1)] and [(1, 1, 1)]. *) 

  val persp : left:float ->
     right:float -> bottom:float -> top:float -> near:float ->
     far:float -> m4
 (** Perspective projection.  Maps the frustum with top of the
     underlying pyramid at the origin, near clip rectangle corners
     [(left, bottom, -near)], [(right, top, -near)] and far plane at
     [-far] to the cube with corners [(-1, -1, -1)] and [(1,1,1)]. *)

     val persp_fov : fovy:float -> aspect:float -> near:float ->
     far:float -> m4
  (** Perspective projection. [fovy] is the field of view, in radians,
      along the y-axis.  [aspect] is the ratio [w/h] of the near clip
      rectangle. [near] and [far] are {e distances} to the near and
      far clip planes.  

      Let [h = 2 * near * (tan fovy/2)] and [w = aspect * h]. The
      transform maps the {e symmetric} frustum with top of the
      underlying pyramid at the origin, near clip rectangle corners
      [(-w/2,-h/2,-near)], [(w/2,h/2,-near)] and far plane at
      [-far] to the cube with corners [(-1, -1, -1)] and [(1,1,1)]. *)

*)

  (** {1:transformations4d 4D space transformations} *)

  val scale : v4 -> m4
  (** [scale s] scales 4D space in the x, y, z and w dimensions according
      to [s]. *)

  (** {1:traversal Traversal} *)

  val map : (float -> float) -> m4 -> m4
  (** [map f a] is the element wise application of [f] to [a]. *)

  val mapi : (int -> int -> float -> float) -> m4 -> m4
  (** [mapi f a] is like {!map} but the element indices are also given. *)

  val fold : ('a -> float -> 'a) -> 'a -> m4 -> 'a
  (** [fold f acc a] is [f (]...[(f (f acc a]{_00}[) a]{_10}[)]...[)]. *)

  val foldi : ('a -> int -> int -> float -> 'a) -> 'a -> m4 -> 'a
  (** [foldi f acc a] is 
      [f (]...[(f (f acc 0 0 a]{_00}[) 1 0 a]{_10}[)]...[)]. *)

  val iter : (float -> unit) -> m4 -> unit
  (** [iter f a] is [f a]{_00}[; f a]{_10}[;] ... *)

  val iteri : (int -> int -> float -> unit) ->  m4 -> unit 
  (** [iteri f a] is [f 0 0 a]{_00}[; f 1 0 a]{_10}[;] ... *)    

  (** {1 Predicates and comparisons} *)

  val for_all : (float -> bool) -> m4 -> bool 
  (** [for_all p a] is [p a]{_00}[ && p a]{_10}[ &&] ...*)

  val exists : (float -> bool) -> m4 -> bool 
  (** [exists p a] is [p a]{_00}[ || p a]{_10}[ ||] ...*)

  val equal : m4 -> m4 -> bool
  (** [equal a b] is [a = b]. *)

  val equal_f : (float -> float -> bool) -> m4 -> m4 -> bool 
  (** [equal_f eq a b] tests [a] and [b] like {!equal} but
      uses [eq] to test floating point values. *)

  val compare : m4 -> m4 -> int
  (** [compare a b] is [Pervasives.compare a b]. That is
      lexicographic comparison in column-major order. *)

  val compare_f : (float -> float -> int) -> m4 -> m4 -> int 
  (** [compare_f cmp a b] compares [a] and [b] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : m4 -> string
  (** [to_string a] is a textual representation of [a]. *)

  val print : Format.formatter -> m4 -> unit
  (** [print ppf a] prints a textual representation of [a] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    m4 -> unit
  (** [print_f pp_e ppf a] prints [a] like {!print} but uses 
      [pp_e] to print floating point values. *)

  (** {1:accessors Element accessors} *)

  val e00 : m4 -> float
  val e01 : m4 -> float
  val e02 : m4 -> float
  val e03 : m4 -> float
  val e10 : m4 -> float
  val e11 : m4 -> float
  val e12 : m4 -> float
  val e13 : m4 -> float
  val e20 : m4 -> float
  val e21 : m4 -> float
  val e22 : m4 -> float
  val e23 : m4 -> float
  val e30 : m4 -> float
  val e31 : m4 -> float
  val e32 : m4 -> float
  val e33 : m4 -> float
end

(** {1:quaternions Quaternions} 

    Unit {{:http://mathworld.wolfram.com/Quaternion.html}quaternions}
    represent rotations in 3D space. They allow to smoothly
    interpolate between orientations. A quaternion is a 4D vector,
    whose components [x], [y], [z], [w] represents the quaternion
    [x]i+ [y]j + [z]k + [w]. *)

type quat = v4
(** The type for quaternions. *)

module Quat : sig

  type t = quat
  (** The type for quaternions. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> float -> quat
  (** [v x y z w] is the quaternion [x]i+ [y]j + [z]k + [w]. *) 

  val zero : quat
  (** [zero] is the zero quaternion. *)  

  val id : quat
  (** [id] is the identity quaternion [1]. *)

  (** {1:functions Functions} *)

  val mul : quat -> quat -> quat
  (** [mul q r] is the quaternion multiplication [q * r]. *)

  val conj : quat -> quat
  (** [conj q] is the 
      {{:http://mathworld.wolfram.com/QuaternionConjugate.html}quaternion 
      conjugate} [q*]. *)

  val unit : quat -> quat
  (** [unit q] is the unit vector [q/|q|] (same as {!V4.unit}). *) 

  val inv : quat -> quat
  (** [inv q] is the quaternion inverse [q]{^ -1}. *)

  val slerp : quat -> quat -> float -> quat
  (** [slerp q r t] is the spherical linear interpolation between [q]
      and [r] at [t]. Non commutative, torque minimal and constant
      velocity. *)

  val squad : quat -> quat -> quat -> quat -> float -> quat
  (** [squad q cq cr r t] is the spherical cubic interpolation
      between [q] and [r] at [t]. [cq] and [cr] indicate the tangent
      orientations at [q] and [r]. *)

  val nlerp : quat -> quat -> float -> quat
  (** [nlerp q r t] is the normalized linear interpolation between [q]
      and [r] at [t].  Commutative, torque minimal and inconstant
      velocity. *)

  (** {1:transformations3d 3D space transformations} *)

  val rot_map : v3 -> v3 -> quat
  (** Unit quaternion for the rotation, see {!M3.rot_map}. *)

  val rot_axis : v3 -> float -> quat 
  (** Unit quaternion for the rotation, see {!M3.rot_axis}. *)

  val rot_zyx : v3 -> quat
  (** Unit quaternion for the rotation, see {!M3.rot_zyx}. *)

  val of_m3 : m3 -> quat
  (** [of_m3 m] is the unit quaternion for the rotation in [m]. *)

  val of_m4 : m4 -> quat
  (** [of_m4 m] is the unit quaternion for the rotation in the 3x3
      top left matrix in [m]. *)

  val to_zyx : quat -> v3
  (** [to_zyx q] is the x, y, z axis angles of the {e unit} quaternion [q]. *)

  val to_axis : quat -> v3 * float
  (** [to_axis q] is the rotation axis and angle of the {e unit} 
      quaternion [q].*)
  
  val to_m3 : quat -> m3
  (** [to_m3 q] is the rotation of the {e unit} quaternion [q] as
      3D matrix. *)

  val to_m4 : quat -> m4
  (** [to_m4 q] is the rotation of the {e unit} quaternion [q] as
      4D matrix. *)

  val apply3 : quat -> v3 -> v3 
  (** [apply3 q v] applies the 3D rotation of the {e unit} quaternion
      [q] to the vector (or point) [v]. *)

  val apply4 : quat -> v4 -> v4
  (** [apply4 q v] apply the 3D rotation of the {e unit} quaternion
      [q] to the homogenous vector (or point) [v]. *)
end

(** {1:sizes Sizes} 
    
    An n-dimensional {e size} [s] represents extents in n-dimensional space.
*)

type size2 = v2
(** The type for sizes in 2D space. *)

type size3 = v3
(** The type for sizes in 3D space. *)

(** Implemented by all size types. {1:top  }*)
module type Size = sig
  type t
  (** The type for sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!t}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val zero : t
  (** [zero] is the zero size, zero extent in each dimension. *)
end

module Size2 : sig
(** In 2D space, {e width} is the extent along the x-axis and 
    {e height} the extent along the y-axis.

    {1:top  }*)

  type t = size2
  (** The type for 2D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size2}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> size2
  (** [v w h] is a size of width [w] and height [h]. *)

  val w : size2 -> float
  (** [w s] is the width of [s]. *)

  val h : size2 -> float
  (** [h s] is the height of [s]. *)

  val zero : size2
  (** [zero] is the zero size, zero width and height. *)
end

module Size3 : sig
(** In 3D space, {e width} is the extent along the x-axis, 
    {e height} the extent along the y-axis and {e depth}
    the extent along the z-axis. 

    {1:top  }*)

  type t = size3
  (** The type for 3D sizes. *)

  val dim : int
  (** [dim] is the dimension of sizes of type {!size3}. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : float -> float -> float -> size3
  (** [v w h d] is a size of width [w], height [h] and depth [d]. *)

  val w : size3 -> float
  (** [w s] is the width of [s]. *)

  val h : size3 -> float
  (** [h s] is the height of [s]. *)

  val d : size3 -> float
  (** [d s] is the depth of [s]. *)

  val zero : size3
  (** [zero] is the zero size, zero width, height and depth. *)
end

(** {1:aboxes Axis-aligned boxes} 

    An n-dimensional axis-aligned box [b] is defined by an
    n-dimensional point [o], its {e origin}, and an n-dimensional size
    [s]. Operations on boxes with negative sizes are undefined.

    The space S([b]) spanned by [b] is \[[o]{_0};
    [o]{_0} + [s]{_0}\] x ... x \[[o]{_n-1}; [o]{_n-1} +
    [s]{_n-1}\]. The extremum points of this space are the box's {e
    corners}. There is a distinguished n-dimensional [empty] box such
    that S([empty]) is empty.  *)

type box2
(** The type for 2D axis-aligned boxes 
    ({{:http://mathworld.wolfram.com/Rectangle.html}rectangles}). *)

type box3
(** The type for 3D axis-aligned boxes
    ({{:http://mathworld.wolfram.com/Cuboid.html}cuboids}). *)

(** Implemented by all axis-aligned box types. {1:top  }*)
module type Box = sig
  type t
  (** The type for boxes. *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!t}. *)

  type v 
  (** The type for {!dim} vectors. *)

  type p 
  (** The type for {!dim} points. *)

  type size 
  (** The type for {!dim} sizes. *)

  type m
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations}
      of {!dim} space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p -> size -> t
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val empty : t
  (** [empty] is {e the} empty box. *)

  val o : t -> p
  (** [o b] is the origin of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val size : t -> size
  (** [size b] is the size of [b]. 

      {b Raises} [Invalid_argument] on {!empty} *)

  val zero : t
  (** [zero] is a box whose origin and size is zero. *)

  val unit : t 
  (** [unit] is the unit box which extends from zero to 
      one in all dimensions. *)

  val of_pts : p -> p -> t
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  (** {1:functions Functions} *)

  val min : t -> p
  (** [min b] is the smallest point of [b] (its origin). 

      {b Raises} [Invalid_argument] on {!empty} *)

  val max : t -> p
  (** [max b] is the greatest point of [b] (its size added to the origin). 

      {b Raises} [Invalid_argument] on {!empty} *)

  val mid : t -> p 
  (** [mid b] is the mid point between [min] and [max]. 

      {b Raises} [Invalid_argument] on {!empty} *)

  val area : t -> float
  (** [area b] is the surface area of [b]. *)

  val inter : t -> t -> t
  (** [inter b b'] is a box whose space is the intersection of S([b]) 
      and S([b']). *)

  val union : t -> t -> t 
  (** [union b b'] is the smallest box whose space contains 
      S([b]) and S([b']). *)

  val inset : v -> t -> t 
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the resulting size is negative returns {!empty}.  Returns
      {!empty} on {!empty}. *)

  val round : t -> t 
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v -> t -> t 
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m -> t -> t 
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> t -> t 
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1 Predicates and comparisons} *)

  val is_empty : t -> bool 
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : t -> bool 
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val isects : t -> t -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : t -> t -> bool 
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p -> t -> bool 
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : t -> t -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> t -> t -> bool 
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : t -> t -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> t -> t -> int 
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : t -> string
  (** [to_string b] is a textual representation of [b]. *)

  val print : Format.formatter -> t -> unit
  (** [print ppf b] prints a textual representation of [b] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    t -> unit
  (** [print_f pp_fl ppf b] prints [b] like {!print} but uses 
      [pp_fl] to print floating point values. *)
end

module Box2 : sig
  type t = box2
  (** The type for 2D boxes 
      ({{:http://mathworld.wolfram.com/Rectangle.html}rectangles}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box2}. *)

  type v = v2
  (** The type for 2D vectors. *)

  type p = p2
  (** The type for 2D points. *)

  type size = size2
  (** The type for 2D sizes. *)

  type m = m2
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations} of 2D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p2 -> size -> box2
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val empty : box2
  (** [empty] is {e the} empty box. *)

  val o : box2 -> p2
  (** [o b] is the origin of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val ox : box2 -> float 
  (** [ox b] is [V2.x (o b)]. *)

  val oy : box2 -> float 
  (** [oy b] is [V2.y (o b)]. *)

  val size : box2 -> size
  (** [size b] is the size of [b]. 

      {b Raises} [Invalid_argument] on {!empty} *)

  val w : box2 -> float 
  (** [w b] is [Size2.w (size b)]. *)

  val h : box2 -> float 
  (** [h b] is [Size2.h (size b)]. *)

  val zero : box2
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box2 
  (** [unit] is the unit box which extends from zero to 
      one in all dimensions. *)

  val of_pts : p2 -> p2 -> box2
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  (** {1:functions Functions} *)

  val min : box2 -> p2
  (** [min b] is the smallest point of [b] (its origin). 

      {b Raises} [Invalid_argument] on {!empty} *)

  val minx : box2 -> float 
  (** [minx b] is [V2.x (min b)]. *)

  val miny : box2 -> float 
  (** [miny b] is [V2.y (min b)]. *)

  val max : box2 -> p2
  (** [max b] is the greatest point of [b] (its size added to the origin). 

      {b Raises} [Invalid_argument] on {!empty} *)

  val maxx : box2 -> float 
  (** [maxx b] is [V2.x (max b)]. *)

  val maxy : box2 -> float 
  (** [maxy b] is [V2.y (max b)]. *)

  val mid : box2 -> p2 
  (** [mid b] is the mid point between [min] and [max]. 

      {b Raises} [Invalid_argument] on {!empty} *)

  val midx : box2 -> float 
  (** [midx b] is [V2.x (mid b)]. *)

  val midy : box2 -> float 
  (** [midy b] is [V2.y (mid b)]. *)

  val bottom_left : box2 -> p2
  (** [bottom_left b] is the bottom-left corner of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val bottom_right : box2 -> p2
  (** [bottom_right b] is the bottom-right corner of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val top_left : box2 -> p2
  (** [top_left b] is the top-left corner of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val top_right : box2 -> p2
  (** [top_right b] is the top-right corner of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val area : box2 -> float
  (** [area b] is the surface area of [b]. *)

  val inter : box2 -> box2 -> box2
  (** [inter b b'] is a box whose space is the intersection of S([b]) 
      and S([b']). *)

  val union : box2 -> box2 -> box2 
  (** [union b b'] is the smallest box whose space contains 
      S([b]) and S([b']). *)

  val inset : v2 -> box2 -> box2 
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the resulting size is negative returns {!empty}.  Returns
      {!empty} on {!empty}. *)

  val round : box2 -> box2 
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v2 -> box2 -> box2 
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m2 -> box2 -> box2 
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m3 -> box2 -> box2 
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 2D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box2 -> box2 
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1 Predicates and comparisons} *)

  val is_empty : box2 -> bool 
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box2 -> bool 
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val is_seg : box2 -> bool 
  (** [is_seg b] is [true] iff [b] is not {!empty} and its size is 
      equal to 0 in exactly one dimension. *)

  val isects : box2 -> box2 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box2 -> box2 -> bool 
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p2 -> box2 -> bool 
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box2 -> box2 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box2 -> box2 -> bool 
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box2 -> box2 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> box2 -> box2 -> int 
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : box2 -> string
  (** [to_string b] is a textual representation of [b]. *)

  val print : Format.formatter -> box2 -> unit
  (** [print ppf b] prints a textual representation of [b] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    box2 -> unit
  (** [print_f pp_fl ppf b] prints [b] like {!print} but uses 
      [pp_fl] to print floating point values. *)
end


module Box3 : sig
  type t = box3
  (** The type for 3D boxes
      ({{:http://mathworld.wolfram.com/Cuboid.html}cuboids}). *)

  val dim : int
  (** [dim] is the dimension of the boxes of type {!box3}. *)

  type v = v3
  (** The type for 3D vectors. *)

  type p = p3
  (** The type for 3D points. *)

  type size = size3
  (** The type for 3D sizes. *)

  type m = m3
  (** The type for matrices representing
      {{:http://mathworld.wolfram.com/LinearTransformation.html}linear 
      transformations} of 3D space. *)

  (** {1:cons Constructors, accessors and constants} *)

  val v : p3 -> size3 -> box3
  (** [v o size] is a box whose origin is [o] and size is [size]. *)

  val empty : box3
  (** [empty] is {e the} empty box. *)

  val o : box3 -> p3
  (** [o b] is the origin of [b].

      {b Raises} [Invalid_argument] on {!empty} *)

  val ox : box3 -> float 
  (** [ox b] is [V3.x (o b)]. *)

  val oy : box3 -> float 
  (** [oy b] is [V3.y (o b)]. *)

  val oz : box3 -> float 
  (** [oz b] is [V3.z (o b)]. *)

  val size : box3 -> size3
  (** [size b] is the size of [b]. 

      {b Raises} [Invalid_argument] on {!empty} *)

  val w : box3 -> float 
  (** [w b] is [Size3.w (size b)]. *)

  val h : box3 -> float 
  (** [h b] is [Size3.h (size b)]. *)

  val d : box3 -> float 
  (** [d b] is [Size3.d (size b)]. *)

  val zero : box3
  (** [zero] is a box whose origin and size is zero. *)

  val unit : box3 
  (** [unit] is the unit box which extends from zero to 
      one in all dimensions. *)

  val of_pts : p3 -> p3 -> box3
  (** [of_pts p p'] is the smallest box whose space contains [p] and [p']. *)

  (** {1:functions Functions} *)

  val min : box3 -> p3
  (** [min b] is the smallest point of [b] (its origin). 

      {b Raises} [Invalid_argument] on {!empty} *)

  val minx : box3 -> float 
  (** [minx b] is [V3.x (min b)]. *)

  val miny : box3 -> float 
  (** [miny b] is [V3.y (min b)]. *)

  val minz : box3 -> float 
  (** [minz b] is [V3.z (min b)]. *)

  val max : box3 -> p3
  (** [max b] is the greatest point of [b] (its size added to the origin). 

      {b Raises} [Invalid_argument] on {!empty} *)

  val maxx : box3 -> float 
  (** [maxx b] is [V3.x (max b)]. *)

  val maxy : box3 -> float 
  (** [maxy b] is [V3.y (max b)]. *)

  val maxz : box3 -> float 
  (** [maxz b] is [V3.z (max b)]. *)

  val mid : box3 -> p3 
  (** [mid b] is the mid point between [min] and [max]. 

      {b Raises} [Invalid_argument] on {!empty} *)

  val midx : box3 -> float 
  (** [midx b] is [V3.x (mid b)]. *)

  val midy : box3 -> float 
  (** [midy b] is [V3.y (mid b)]. *)

  val midz : box3 -> float 
  (** [midz b] is [V3.z (mid b)]. *)

  val area : box3 -> float
  (** [area b] is the surface area of [b]. *)

  val volume : box3 -> float 
  (** [volume b] is the volume of [b]. *)

  val inter : box3 -> box3 -> box3
  (** [inter b b'] is a box whose space is the intersection of S([b]) 
      and S([b']). *)

  val union : box3 -> box3 -> box3 
  (** [union b b'] is the smallest box whose space contains 
      S([b]) and S([b']). *)

  val inset : v3 -> box3 -> box3 
  (** [inset d b] is [b] whose edges are inset in each dimension
      according to amounts in [d]. Negative values in [d] outset. If
      the resulting size is negative returns {!empty}.  Returns
      {!empty} on {!empty}. *)

  val round : box3 -> box3 
  (** [round b] is the smallest box containing [b] with integer valued
      corners. Returns {!empty} on {!empty}. *)

  val move : v3 -> box3 -> box3 
  (** [move d b] is [b] translated by [d]. Returns {!empty} on {!empty}. *)

  val ltr : m3 -> box3 -> box3 
  (** [ltr m b] is the smallest box containing the corners of [b] transformed
      by [m]. Returns {!empty} on {!empty}. *)

  val tr : m4 -> box3 -> box3 
  (** [tr m b] is the smallest box containing the corners of [b] transformed
      by [m] in homogenous 3D space. Returns {!empty} on {!empty}. *)

  val map_f : (float -> float) -> box3 -> box3 
  (** [map_f f b] is the box whose origin and size are those of [b] with
      their components mapped by [f]. Returns {!empty} on {!empty}. *)

  (** {1 Predicates and comparisons} *)

  val is_empty : box3 -> bool 
  (** [is_empty b] is [true] iff [b] is {!empty}. *)

  val is_pt : box3 -> bool 
  (** [is_pt b] is [true] iff [b] is not {!empty} and its size is equal
      to 0 in every dimension. *)

  val is_plane : box3 -> bool 
  (** [is_plane b] is [true] iff the size of [b] is equal to 0 in exactly
      one dimension. *)

  val is_seg : box3 -> bool 
  (** [is_seg b] is [true] iff [b] is not {!empty} and its size is 
      equal to 0 in exactly two dimensions. *)

  val isects : box3 -> box3 -> bool
  (** [isects b b'] is [not (is_empty (inter b b'))]. *)

  val subset : box3 -> box3 -> bool 
  (** [subset b b'] is [true] iff S([b]) is included in S([b']). *)

  val mem : p3 -> box3 -> bool 
  (** [mem p b] is [true] iff [p] is in S([b]). *)

  val equal : box3 -> box3 -> bool
  (** [equal b b'] is [b = b']. *)

  val equal_f : (float -> float -> bool) -> box3 -> box3 -> bool 
  (** [equal_f eq b b'] tests [b] and [b'] like {!equal}
      but uses [eq] to test floating point values. *)

  val compare : box3 -> box3 -> int
  (** [compare u v] is [Pervasives.compare u v]. *)

  val compare_f : (float -> float -> int) -> box3 -> box3 -> int 
  (** [compare_f cmp b b'] compares [b] and [b'] like {!compare}
      but uses [cmp] to compare floating point values. *)

  (** {1:printers Printers} *)
  
  val to_string : box3 -> string
  (** [to_string b] is a textual representation of [b]. *)

  val print : Format.formatter -> box3 -> unit
  (** [print ppf b] prints a textual representation of [b] on [ppf]. *)

  val print_f : (Format.formatter -> float -> unit) -> Format.formatter -> 
    box3 -> unit
  (** [print_f pp_fl ppf b] prints [b] like {!print} but uses 
      [pp_fl] to print floating point values. *)
end

(** {1:colors Colors} *)

type color = v4
(** The type for colors, see  {{!Color.t}details}. *)

(** Colors and color profiles.

    [Color] provides some function to operate on {{!t}color} values
    and basic support for ICC based {{!profile}color profiles} to 
    precisely specify how to interpret raw color samples. Thorough color 
    profile support and conversion is provided byte the {!Gcolor} module.

    {3 References.}
    {ul
    {- Charles Poynton. 
       {e {{:http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html}
       Frequently asked questions about color}}. 2006}
    {- Charles Poynton. 
       {e {{:http://www.poynton.com/PDFs/Guided_tour.pdf}A guided tour of 
       color space}}. 1997}
    {- Bruce MacEvoy. 
       {{:http://www.handprint.com/LS/CVS/color.html}Color
       vision} and
      {{:http://www.handprint.com/HP/WCL/color7.html}modern color models}.}
    {- International Color Consortium. 
       {e {{:http://www.color.org/icc_specs2.xalter}ICC.1:2010-12 Image 
       technology colour management - Architecture, profile format, and 
       data structure}}. 2010.}}

*)
module Color : sig

  (** {1:colors Constructors, accessors and constants} *)

  type t = color
  (** The type for colors in a device independent RGB color space with
      an alpha component. The color space is defined by a D65 white
      point and the ITU-R BT.709 primary (corresponds to a {e
      linearized}
      {{:http://www.color.org/chardata/rgb/srgb.xalter}sRGB} space).
      The {e alpha} component represent the color's opacity ranging
      from [0.], a fully transparent color, to [1.] a completly opaque
      one. *)

  type stops = (float * color) list
  (** The type for color stops. A piecewise linear color curve. *)  

  val v : float -> float -> float -> float -> color
  (** [v r g b a] is the color [(r, g, b, a)]. *)

  val r : color -> float 
  (** [r c] is the [r] component of [c]. *)

  val g : color -> float
  (** [g c] is the [g] component of [c]. *)

  val b : color -> float
  (** [b c] is the [b] component of [c]. *)

  val a : color -> float
  (** [a c] is the [a] component of [c]. *)

  val void : color
  (** [void] is [(color 0. 0. 0. 0.)] an invisible color. *)

  val black : color
  (** [black] is [(color 0. 0. 0. 1.)] *)

  val of_gray : ?a:float -> float -> color 
  (** [of_gray a g] is ([color g g g a]) *)

  val white : color
  (** [white] is [(color 1. 1. 1. 1.)] *)

  val red : color
  (** [red] is [(color 1. 0. 0. 1.)] *)

  val green : color
  (** [green] is [(color 0. 1. 0. 1.)] *)

  val blue : color
  (** [blue] is [(color 0. 0. 1. 1.)] *)

  (** {1 Basic color conversions} *)
  
  type srgba = v4
  (** The type for colors in the 
     {{:http://www.color.org/chardata/rgb/srgb.xalter}sRGB} color space 
     with an alpha component. This is the color space used, for example,
     by CSS. *)

  val of_srgba : srgba -> color 
  (** [of_srgba c] is the {{!srgba}sRGBA} color [c] as a {{!t}color} value. *)

  val to_srgba : color -> srgba
  (** [to_srgba c] is the {{!t}color} value [c] as a {{!srgba}sRGBA} color. *)

  type lcha = v4
  (** The type for colors in the CIE L*C*h* color space with a D50 reference 
      white point and an alpha component. This color space is CIE L*a*b* with 
      polar coordinates, the meaning and range of the components is:
     {ul
     {- L* is the lightness in the range [0.] to [100.].}
     {- C* represents chroma, in the range [0.] to 
        [181.02], but less in practice.}
     {- h* represents hue in degrees in the range [0.] to [2pi].}}
   *)

  val of_lcha : lcha -> color 
  (** [of_lcha c] is the {{!lcha}LChA} color [c] as a {{!t}color} value. *)

  val to_lcha : color -> lcha
  (** [to_lcha c] is the {{!t}color} value [c] as a {{!lcha}LChA} color. *)

  type laba = v4
  (** The type for colors in the CIE L*a*b* color space with a D50 reference
      white point and an alpha component. The meaning and range of the 
      components is:
      {ul
      {- L* is lightness in the range [0.] to [100.]}
      {- a* and b*'s practical range is [-128.] to [127.]}}
   *)

  val of_laba : laba -> color 
  (** [of_laba c] is the {{!laba}LabA} color [c] as a {{!t}color} value. *)

  val to_laba : color -> laba
  (** [to_laba c] is the {{!t}color} value [c] as a {{!laba}LabA} color. *)

  val to_gray : color -> float
  (** [to_gray c] is the {{!t}color} value [c] converted to grayscale *)

  (** {1 Color spaces} *)

  type space = [ 
    | `XYZ | `Lab | `Luv | `YCbr | `Yxy | `RGB | `Gray | `HSV | `HLS 
    | `CMYK | `CMY | `CLR2 | `CLR3 | `CLR4 | `CLR5 | `CLR6 | `CLR7 
    | `CLR8 | `CLR9 | `CLRA | `CLRB | `CLRC | `CLRD | `CLRE | `CLRF ]
  (** The type for color spaces. These correspond to the ICC v4 supported 
      color space, see the
      {{:http://www.color.org/icc_specs2.xalter}specification},
      section 7.2.6. *) 

  val space_dim : space -> int
  (** [space_dim s] is the dimension of the color space [s]. *)

  val pp_space : Format.formatter -> space -> unit 
  (** [pp_space s] prints a textual representation of [s] on [ppf]. *)

  (** {1:colorprofiles Color profiles} *)

  type profile 
  (** The type for {{:http://www.color.org/}ICC} color profiles. A
      color profile can describe the characteristics of a color space,
      an input or output device and provide a mapping to a profile
      connection space (PCS), which is either CIE L*a*b* or XYZ with a
      D50 white point.  For more information about ICC profile consult
      the {{:http://www.color.org/faqs.xalter}ICC FAQ} and the
      {{:http://color.org/icc_specs2.xalter}ICC v4 specification}.

      This module defines only a profile for the color space of 
      {!color} and a grayscale color space. More profiles and
      profile constructors can be found in {!Gcolor.ICC}. *)

  val profile_of_icc : string -> profile option
  (** [profile_of_icc s] is a profile from the ICC profile byte 
      stream [s]. [None] is returned if [s] doesn't seem to be a ICC profile. 

      {b Note} A profile value is returned if a color space can be 
      extracted, it doesn't guarantee a correct ICC profile byte stream. *)

  val profile_to_icc : profile -> string 
  (** [profile_to_icc p] is [p]'s ICC profile byte stream. *)
  
  val profile_space : profile -> space
  (** [profile_space p] is [p]'s color space. *)

  val profile_dim : profile -> int
  (** [profile_space p] is [space_dim (profile_space d)]. *)

  val p_lgray : profile 
  (** [p_lgray] is a linear gray color profile *)

  val p_lrgb : profile
  (** [p_lrgb] is the color profile of {{!t}color} values. *)
end

(** {1:raster Raster data} *)

type raster
(** The type for raster data. *)

(** Raster data.

    Raster data organizes data samples of any dimension in discrete
    1D, 2D (images) or 3D space.

    A sample has a {{!type:sample_semantics}{e semantics}} that defines its
    dimension and the meaning of its {e components}. For example a 4D
    sample could represent a linear sRGBA sample. Samples are stored
    in a {{!type:buffer}linear buffer} of {e scalars} of a given
    {{!type:scalar_type}type}. A sample can use one scalar per component,
    can be packed in a single scalar or may have no direct obvious
    relationship to buffer scalars (compressed data). A
    {{!type:sample_format}sample format} defines the semantics and
    scalar storage of a sample.

    A {{!t}{e raster data}} value is a collection of samples indexed by width, 
    height and depth (i.e. x, y, z) stored in a buffer. It defines
    the sample data, the extents of the index and the sample format.

    {b Spatial convention.} If the sample index has to be interpreted
    spatially. It must be interpreted relative to the origin of a
    right-handed coordinate system. This means that the first sample,
    indexed by [(0, 0, 0)] is the bottom-left backmost sample
    (bottom-left sample for an image). *) 
module Raster : sig

  (** {1:scalars Scalar types and buffers} *)

  type scalar_type = 
    [ `Int8 | `Int16 | `Int32 | `Int64 
    | `Uint8 | `Uint16 | `Uint32 | `Uint64
    | `Float16 | `Float32 | `Float64 ]
  (** The type for scalar types. *)

  val scalar_type_byte_count : scalar_type -> int 
  (** [scalar_type_byte_count st] is the number of bytes used by a scalar
      of type [st]. *)

  val pp_scalar_type : Format.formatter -> scalar_type -> unit 
  (** [pp_scalar_type ppf st] prints a textual representation of [st]
      on [ppf]. *)

  type ('a, 'b) b_array = ('a, 'b, Bigarray.c_layout) Bigarray.Array1.t 
  (** The type for big arrays. *)

  type buffer = [ 
  | `S_Uint8 of string 
  | `A_Float64 of float array
  | `B_Int8 of (int, Bigarray.int8_signed_elt) b_array
  | `B_Int16 of (int, Bigarray.int16_signed_elt) b_array
  | `B_Int32 of (int32, Bigarray.int32_elt) b_array
  | `B_Int64 of (int64, Bigarray.int64_elt) b_array
  | `B_Uint8 of (int, Bigarray.int8_unsigned_elt) b_array
  | `B_Uint16 of (int, Bigarray.int16_unsigned_elt) b_array
  | `B_Uint32 of (int32, Bigarray.int32_elt) b_array
  | `B_Uint64 of (int64, Bigarray.int64_elt) b_array
  | `B_Float16 of (int, Bigarray.int16_unsigned_elt) b_array
  | `B_Float32 of (float, Bigarray.float32_elt) b_array
  | `B_Float64 of (float, Bigarray.float64_elt) b_array ]
  (** The type for linear buffer of scalars. *)

  val buffer_scalar_type : buffer -> scalar_type 
  (** [buffer_scalar_type b] is [b]'s buffer scalar type. *)
  
  (** {1:semantics Sample semantics} *)

  type sample_semantics = 
    [ `Other of int * string
    | `Color of Color.profile * bool]
  (** The type for sample semantics. 
      {ul 
      {- [`Color (p, alpha)] is for color samples from the
         color profile [p]. [alpha] indicates if there's an alpha
         component on the {e right} of the color components.}
      {- [`Other(dim, label)] is for samples of [dim] dimensions. [label]
         can be used to identify the sample semantics.}} *)
  
  val lrgb : sample_semantics 
  (** [lrgb] is for linear RGB samples from the {!Color.p_lrgb}
      profile. *)
  
  val lrgba : sample_semantics
  (** [lrgba] is for linear RGB samples from the  {!Color.p_lrgb} 
      profile with an alpha component. *)

  val lgray : sample_semantics
  (** [lgray] is for linear Gray samples from the {!Color.p_lgray} 
      profile. *)

  val lgraya : sample_semantics
  (** [lgraya] is for linear Gray samples from the {!Color.p_lgray} 
      luminance with an alpha component. *)

  val pp_sample_semantics : Format.formatter -> sample_semantics -> unit 
  (** [pp_sample_semantics ppf sem] prints a textual representation of [sem] 
      on [ppf]. *)

  (** {1:samples Sample format} *)

  type sample_pack =
    [ `PU8888 | `FourCC of string * scalar_type option
    | `Other of string * scalar_type option ]
  (** The type for sample packs. A sample pack describes storage for samples 
      that do not use one scalar per component. 
      {ul 
      {- [`PU8888]. An arbitrary 4D sample X, Y, Z, W with unsigned
         8 bits components packed in a single [`Uint32] scalar 
         as [0xXXYYZZWWl].}
      {- [`FourCC(code, restrict)]. A sample is stored according to the
         format specified by the FourCC [code], a string of length 4.
         If [restrict] is specified the pack can only be used with the
         corresponding scalar type. For example [`FourCC("DXT5", Some
         `Uint64)] can be used to specify a buffer of DXT5 compressed
         data. [`FourCC] can also be used to describe the numerous YUV
         packed pixel formats.}
      {- [`Other(label, restrict)]. A sample is stored in some other
         packing scheme identified by [label], [restrict] has the same
         meaning as in [`FourCC].}}
  *)

  val pp_sample_pack : Format.formatter -> sample_pack -> unit 
  (** [pp_sample_pack ppf pack] prints a textual representation of [pack]
      on [ppf]. *)

  type sample_format
  (** The type for sample formats. *)
  
  val sample_format_v : ?pack:sample_pack -> sample_semantics -> 
    scalar_type -> sample_format 
  (** [sample_format_v pack sem st] is a sample format with semantics 
      [sem] and scalar type [st]. If [pack] is absent one scalar of type [st] 
      per sample component is used. If present, see {!type:sample_pack}.

     {b Raises.} [Invalid_argument] if [pack] is incompatible with [st], 
     see {!type:sample_pack} or if a [pack] [`FourCC] code is not made of 
     4 bytes. *)

  val sf_semantics : sample_format -> sample_semantics 
  (** [sf_semantics sf] is [sf]'s semantics. *)

  val sf_scalar_type : sample_format -> scalar_type 
  (** [sf_scalar_type sf] is [sf]'s buffer scalar type *)

  val sf_pack : sample_format -> sample_pack option
  (** [sf_pack sf] is [sf]'s sample pack, if any. *)

  val sf_dim : sample_format -> int
  (** [sf_dim sf] is [sf]'s sample dimension. *)

  val sf_scalar_count : ?first:int -> ?w_skip:int -> ?h_skip:int -> 
    w:int -> ?h:int -> ?d:int -> sample_format -> int
  (** [sf_scalar_count first w_skip h_skip w h d sf] is the minimal 
      number of scalars needed to hold a raster data with the corresponding 
      parameters, see {!v} for their description. 

      {b Raises} [Invalid_argument] if [sf] is packed. *)

  val pp_sample_format : Format.formatter -> sample_format -> unit 
  (** [pp_sample_format ppf sf] prints a textual representation of [sf]
      on [ppf].*)

  (** {1:raster Raster data} *)
    
  type t = raster
  (** The type for raster data. *)

  (** {2 Constructor, accessors} *)

  val v : ?res:v3 -> ?first:int -> ?w_skip:int -> 
  ?h_skip:int -> w:int -> ?h:int -> ?d:int -> sample_format -> buffer -> t
  (** [v res first w_skip h_skip w h d sf buf] is raster data with 
      sample format [sf] and buffer [b].
      {ul
      {- [w], [h], [d], specify the index width, height and depth, in 
         number of {e samples}. [h] and [d] default to [1].}
      {- [first], {e buffer scalar} index where the data of the first sample
         is stored.}
      {- [w_skip], number of {e buffer scalars} to skip between two 
         consecutive lines, defaults to [0].} 
      {- [h_skip], number of {e buffer scalars} to skip between two 
         consecutive planes, defaults to [0].}
      {- [res], is an optional sample resolution specification in 
         samples per meters.}}
     For certain sample formats [first], [w_skip] and [h_skip] can be used 
     to specify subspaces in the collection of samples, see {!sub}. 

     The function {!pitches} can be used to easily compute the buffer
     scalar index where a sample [(x,y,z)] starts.

  {b Raises} [Invalid_argument] if [w], [h] or [d] is not positive or 
  if [first], [w_skip] or [h_skip] is negative. Or if the scalar type of 
  [sf] doesn't match [(Raster.buffer_scalar_type b)].
*)

  val res : t -> v3 option
  (** [res r] is [r]'s resolution in sample per meters, if any. *)
  
  val first : t -> int
  (** [first r] is the {e buffer scalar} index where the first sample 
      is stored. *)
  
  val w_skip : t -> int
  (** [w_skip r] is the number of {e buffer scalars} to skip between 
      two consecutive lines. *)

  val h_skip : t -> int
  (** [f_h_skip r] is the number of {e buffer scalars} to skip 
      between two consecutive planes. *)

  val w : t -> int
  (** [w r] is the index width in number of {e samples}. *)

  val h : t -> int
  (** [h r] is the index height in number of {e samples}. *)

  val d : t -> int
  (** [d r] is the index depth in number of {e samples}. *)

  val sample_format : t -> sample_format
  (** [f_sample_format r] is [r]'s sample format. *)

  val buffer : t -> buffer
  (** [buffer r] is [r]'s format. *)

  (** {2 Functions} *)

  val dim : t -> int
  (** [dim r] is [r]'s index dimension from 1 to 3. *)

  val size2 : t -> size2
  (** [size2 r] is [r]'s index width and height as floats. *)

  val size3 : t -> size3
  (** [size3 r] is [r]'s index width, height and depth as floats. *)

  val sub : ?x:int -> ?y:int -> ?z:int -> ?w:int -> ?h:int -> ?d:int -> 
    t -> t
  (** [sub x y z w h d r] is a raster corresponding to a 
      subset of the index of [r]. Both [r] and the resulting raster 
      share the same buffer.
      {ul
       {- [x], [y], [z], new sample origin of the raster data, 
          defaults to [(0, 0, 0)].}
       {- [w], [h], [d], new size of the index, defaults to [r]'s 
          sizes minus the new sample origin.}}
     {b Raises} [Invalid_argument], if the sample format of [r] is 
     packed, if the origin is out of bounds or if new size is larger than 
     [r]'s size. *)

  val pitches : t -> int * int * int 
  (** [pitches r] is [(x_pitch, y_pitch, z_pitch)] where 
      {ul
       {- [x_pitch] is the number of buffer scalars from sample to sample.}
       {- [y_pitch] is the number of buffer scalars from line to line.} 
       {- [z_pitch] is the number of buffer scalars from plane to plane.}}
      The buffer index where the sample [(x,y,z)] starts is given by: 
{[
(Raster.first r) + z * z_pitch + y * y_pitch + x * x_pitch
]}
  
      {b Raises} [Invalid_argument] if the sample format of [r] is
      packed.
  *)

  (** {2 Printers} *)

  val to_string : t -> string 
  (** [to_string r] is a textual representation of [r]. Doesn't
      print the buffer samples. *)

  val pp : Format.formatter -> t -> unit
  (** [pp ppf t] prints a textual represenation of [t] on [ppf]. Doesn't
      print the buffer samples. *)
end

(** {1:basics Basics} 

    [Gg] is designed to be opened in your module. This defines only
    types and modules in your scope, no values. Thus to use [Gg] start
    with : {[open Gg;;]} 


    For the toplevel, the file [gg_init.ml] opens [Gg] and installs
    printers for the types. It can be used automatically by adding the
    following lines to an [.ocamlinit] file :
{[#directory "/path/to/gg/install";;
#load "gg.cmo";;
#use "gg_init.ml";;]} 

    {2:conventions Conventions}

    Most types and their functions are defined with the following
    conventions. The type is first defined in [Gg], like {!v2} for 2D
    vectors.  A module for the type is is defined in [Gg]. Its name is
    the type name capitalized, e.g. {!V2} for 2D vectors. This module
    has the following definitions :
    {ul
    {- a type [t] equal to the original toplevel type ({!V2.t}).}    
    {- [dim], an [int] value that indicates the dimensionality 
       of the type ({!V2.dim}).}
    {- [v], a constructor for the type ({!V2.v}).}
    {- [to_string] and [print] to convert values to a textual 
       representation for debugging purposes and toplevel interaction
       ({!V2.to_string}, {!V2.print}).}
    {- [equal] and [compare] the standard functions that make a module 
       a good functor argument ({!V2.equal}, {!V2.compare}).}
    {- [equal_f] and [compare_f] which compare
       like [equal] and [compare] but allow to use a client provided
       function to compare floats ({!V2.equal_f}, {!V2.compare_f}).}
    {- [ltr] and [tr] to apply linear and affine transforms
       on the type ({!V2.ltr}, {!V2.tr}).}
    {- Other accessors (e.g. {!V2.x}), constants (e.g. {!V2.zero}),
       functions (e.g. {!V2.dot}) and predicates (e.g. {!V2.exists})
       specific to the type.}
    {- Modules that represent the same object but for different
       dimensions, like {!V2}, {!V3}, {!V4} for vectors,  usually 
       share a common signature. This common
       signature is collected in a module type defined in [Gg], 
       this signature is {!V} for vectors.}}

    Some types are defined as simple abreviations. For example the
    type {!p2} for 2D points is equal to {!v2}. These types also have
    a module whose name is the type name capitalized, {!P2} in our
    example. However this module only provides alternate constructors,
    constants and accessors and the extended functionality specific to the
    type. You should fallback on the module of the abreviated type
    ({!V2} in our example) for other operations. The aim of these
    types is to make your code and signatures semantically clearer
    without the burden of explicit conversions.

    Finally there are some types and modules like {!Color} whose structure
    is different because they provide specific functionality. 

    Here are a few other conventions : 
    {ul
    {- Numbers in names indicate dimensionality. For example {!M4.move3} 
       indicates translation in 3D space.}
    {- Most functions take the "object" they act upon first.
       But exceptions abound, to match caml conventions, to have your 
       curry or to match mathematical notation (e.g. {!V2.tr}).}
    {- Conversion functions follow the [of_] conventions. Thus to convert
       a value of type [t'] to a value of type [t] look for the function 
       named [T.of_t']. Exception to this rule is the conversion from 
       quaternions to matrices which are defined as [Quat.to_] functions.}}

    To conclude note that it is sometimes hard to find the right place
    for a function. If you cannot find a function look into each of
    the modules of the types you want to act upon.

    {2:mathconv Mathematical conventions}
    {ul
    {- In 3D space we assume a
    {{:http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html}
    right-handed} coordinate system.}
    {- Angles are always given in radians (except in 
      {{:Gg.Float.html#VALrad_of_deg}this} function...).} 
    {- In 2D space positive angles determine counter clockwise rotations.}
    {- In 3D space positive angles determine rotations directed according to 
       the right hand rule.}}

    {2:tipsremarks Remarks and Tips}
    {ul
    {- Everything is tail-recursive.}
    {- [to_string] functions are not thread-safe. Thread-safety can
       be achieved with [print] functions.} 
    {- Do not rely on the output of printer functions, they are
       subject to change. 

       One exception is the {{:Gg.Float.html#printers}printers} in the
       {!Float} module that output a lossless textual representation
       of floats.  While the actual format is subject to change it
       will remain compatible with [float_of_string].}
    {- All modules can be directly given as arguments to [Set.Make]
       and [Map.Make]. However this will use [Pervasives.compare] and
       thus binary comparison between floats. Depending on the intended
       use this may be sensible or not. 

       Comparisons with alternate functions to compare floats can 
       be defined by using the functions named [compare_f] 
       (e.g. {!V2.compare_f}). 

       {!Float.compare_tol} is a comparison function between floats
       that combines relative and absolute float comparison in a single
       test. See {!Float.equal_tol} for the details.}
    {- For performance reasons some functions of the {!Float} module 
       are undefined on certain arguments but do not raise [Invalid_argument]
       on those. As usual do not rely on the behaviour of functions on undefined
       argument, these are subject to change.}}
*)


(*---------------------------------------------------------------------------
   Copyright (c) %%COPYRIGHTYEAR%%, Daniel C. Bünzli
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
     
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

   3. Neither the name of the Daniel C. Bünzli nor the names of
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ---------------------------------------------------------------------------*)
